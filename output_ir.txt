Token(cll_OP) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	str _8 = NONE
	bool success_9 = FALSE
	str _10 = NONE
	bool success_11 = FALSE
	if (!(*pos == '/'))
	{
		if (!(*pos == '-'))
		{
			if (!(*pos == '+'))
			{
				if (!(*pos == '*'))
				{
					if (!(*pos == '%'))
					{
						return {}
					}
					else 
					{
						_10 = CURRENT_POS_SEQUENCE
						success_11 = TRUE
						pos++
						_0 = _10
					}
				}
				else 
				{
					_8 = CURRENT_POS_SEQUENCE
					success_9 = TRUE
					pos++
					_0 = _8
				}
			}
			else 
			{
				_6 = CURRENT_POS_SEQUENCE
				success_7 = TRUE
				pos++
				_0 = _6
			}
		}
		else 
		{
			_4 = CURRENT_POS_SEQUENCE
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
	data = _0 # str
}
Token(cll_ASSIGNMENT_OP) {
	Token_result _0 = NONE
	bool success_1 = FALSE
	Token_result _2 = NONE
	bool success_3 = FALSE
	_0 = cll_OP(TOKEN_SEQUENCE)
	if (_0.status)
	{
		success_1 = TRUE
		pos += _0.token.length()
	}
	skipspaces(pos)
	_2 = AUTO_21(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		error"="

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	data = _0.node # token
}
Token(cll_COMPARE_OP) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	str _8 = NONE
	bool success_9 = FALSE
	str _10 = NONE
	bool success_11 = FALSE
	str _12 = NONE
	bool success_13 = FALSE
	if (!(!STRNCMP(pos, ">=")))
	{
		if (!(!STRNCMP(pos, "==")))
		{
			if (!(!STRNCMP(pos, "<=")))
			{
				if (!(!STRNCMP(pos, "!=")))
				{
					if (!(*pos == '>'))
					{
						if (!(*pos == '<'))
						{
							return {}
						}
						else 
						{
							_12 = CURRENT_POS_SEQUENCE
							success_13 = TRUE
							pos++
							_0 = _12
						}
					}
					else 
					{
						_10 = CURRENT_POS_SEQUENCE
						success_11 = TRUE
						pos++
						_0 = _10
					}
				}
				else 
				{
					_8 = CURRENT_POS_SEQUENCE
					success_9 = TRUE
					pos++
					_0 = _8
				}
			}
			else 
			{
				_6 = CURRENT_POS_SEQUENCE
				success_7 = TRUE
				pos++
				_0 = _6
			}
		}
		else 
		{
			_4 = CURRENT_POS_SEQUENCE
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
	data = _0 # str
}
Token(cll_LOGICAL_OP) {
	token _0 = NONE
	bool success_1 = FALSE
	Token_result _2 = NONE
	bool success_3 = FALSE
	Token_result _4 = NONE
	bool success_5 = FALSE
	_2 = cll_LOGICAL_OR(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		_4 = cll_LOGICAL_AND(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			return {}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		success_3 = TRUE
		pos += _2.token.length()
		_0 = _2.node
	}
	success_1 = TRUE
	data = _0 # token
}
Token(cll_LOGICAL_NOT) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	if (!(!STRNCMP(pos, "not")))
	{
		if (!(*pos == '!'))
		{
			return {}
		}
		else 
		{
			_4 = CURRENT_POS_SEQUENCE
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
}
Token(cll_LOGICAL_AND) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	if (!(!STRNCMP(pos, "and")))
	{
		if (!(!STRNCMP(pos, "&&")))
		{
			return {}
		}
		else 
		{
			_4 = CURRENT_POS_SEQUENCE
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
}
Token(cll_LOGICAL_OR) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	if (!(!STRNCMP(pos, "||")))
	{
		if (!(!STRNCMP(pos, "or")))
		{
			return {}
		}
		else 
		{
			_4 = CURRENT_POS_SEQUENCE
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
}
Token(cll_TYPE) {
	any _0 = NONE
	bool success_1 = FALSE
	any _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	str _8 = NONE
	bool success_9 = FALSE
	str _10 = NONE
	bool success_11 = FALSE
	str _12 = NONE
	bool success_13 = FALSE
	bool success_15 = FALSE
	str _16 = NONE
	bool success_17 = FALSE
	Token_result _18 = NONE
	bool success_19 = FALSE
	bool success_21 = FALSE
	str _22 = NONE
	bool success_23 = FALSE
	Token_result _24 = NONE
	bool success_25 = FALSE
	auto begin_2 = pos
	if (!(!STRNCMP(pos, "bool")))
	{
		if (!(!STRNCMP(pos, "var")))
		{
			if (!(!STRNCMP(pos, "str")))
			{
				if (!(!STRNCMP(pos, "num")))
				{
					if (!(!STRNCMP(pos, "any")))
					{
						auto begin_16 = begin_2
						do
						{
							if (!(!STRNCMP(pos, "obj")))
							{
								break
							}
							_16 += CURRENT_POS_SEQUENCE
							success_17 = TRUE
							begin_16++
							skipspaces(pos)
							_18 = cll_TEMPLATE(TOKEN_SEQUENCE)
							if (!(_18.status))
							{
								errortemplate

								break
							}
							success_19 = TRUE
							begin_16 += _18.token.length()
						}						while(0)

						if (success_17 && success_19)
						{
							success_15 = TRUE
														begin_2 = begin_16
						}
						
						if (!success_15)
						{
							auto begin_22 = begin_2
							do
							{
								if (!(!STRNCMP(pos, "arr")))
								{
									break
								}
								_22 += CURRENT_POS_SEQUENCE
								success_23 = TRUE
								begin_22++
								skipspaces(pos)
								_24 = cll_TEMPLATE(TOKEN_SEQUENCE)
								if (!(_24.status))
								{
									errortemplate

									break
								}
								success_25 = TRUE
								begin_22 += _24.token.length()
							}							while(0)

							if (success_23 && success_25)
							{
								success_21 = TRUE
																begin_2 = begin_22
							}
							
							if (!success_21)
							{
								return {}
							}
						}
					}
					else 
					{
						_12 = CURRENT_POS_SEQUENCE
						success_13 = TRUE
						begin_2++
						_2 = _12
					}
				}
				else 
				{
					_10 = CURRENT_POS_SEQUENCE
					success_11 = TRUE
					begin_2++
					_2 = _10
				}
			}
			else 
			{
				_8 = CURRENT_POS_SEQUENCE
				success_9 = TRUE
				begin_2++
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_POS_SEQUENCE
			success_7 = TRUE
			begin_2++
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_2++
		_2 = _4
	}
	success_3 = TRUE
	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	data = 
		templ: _22 # str
		type: _16 # str
	;
}
Token(cll_TEMPLATE) {
	str _0 = NONE
	bool success_1 = FALSE
	Token_result _2 = NONE
	bool success_3 = FALSE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	Token_result _8 = NONE
	bool success_9 = FALSE
	array shadow_10 = NONE
	str _11 = NONE
	bool success_12 = FALSE
	if (!(*pos == '<'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	_2 = cll_TYPE(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errortype

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(pos)
	auto begin_6 = pos
	while (1)
	{
		if (!(*pos == ','))
		{
			error","

			break
		}
		_6 += CURRENT_POS_SEQUENCE
		success_7 = TRUE
		begin_6++
		skipspaces(pos)
		_8 = cll_TYPE(TOKEN_SEQUENCE)
		if (!(_8.status))
		{
			errortype

			break
		}
		success_9 = TRUE
		begin_6 += _8.token.length()
		shadow_10.push(_8.node)
	}
	if (success_7 && success_9)
	{
		success_5 = TRUE
				pos = begin_6
	}
	skipspaces(pos)
	if (!(*pos == '>'))
	{
		error">"

		return {}
	}
	_11 += CURRENT_POS_SEQUENCE
	success_12 = TRUE
	pos++
	data = 
		second: shadow_10 # array
		first: _2.node # token
	;
}
Rule(cll_if) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_1))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = cll_expr(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorexpr

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(TOKEN_SEQUENCE)
	_4 = cll_block(TOKEN_SEQUENCE)
	if (!(_4.status))
	{
		errorblock

		return {}
	}
	success_5 = TRUE
	pos += _4.token.length()
	data = 
		block: _4.node # rule
		expr: _2.node # rule
	;
}
Rule(cll_variable) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	Rule_result _14 = NONE
	bool success_15 = FALSE
	token _16 = NONE
	bool success_17 = FALSE
	token _18 = NONE
	bool success_19 = FALSE
	token _20 = NONE
	bool success_21 = FALSE
	token _22 = NONE
	bool success_23 = FALSE
	token _24 = NONE
	bool success_25 = FALSE
	auto begin_2 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_2))
		{
			if (!(CURRENT_TOKEN == AUTO_3))
			{
				break
			}
			else 
			{
				_6 = CURRENT_TOKEN
				success_7 = TRUE
				begin_2++
				_2 = _6
			}
		}
		else 
		{
			_4 = CURRENT_TOKEN
			success_5 = TRUE
			begin_2++
			_2 = _4
		}
		success_3 = TRUE
		_0 = _2
	}	while(0)

	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		errorid

		return {}
	}
	_8 = CURRENT_TOKEN
	success_9 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_12 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_4))
		{
			errorauto_4

			break
		}
		_12 = CURRENT_TOKEN
		success_13 = TRUE
		begin_12++
		skipspaces(TOKEN_SEQUENCE)
		_14 = cll_expr(TOKEN_SEQUENCE)
		if (!(_14.status))
		{
			errorexpr

			break
		}
		success_15 = TRUE
		begin_12 += _14.token.length()
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == AUTO_5))
		{
			errorauto_5

			break
		}
		_16 = CURRENT_TOKEN
		success_17 = TRUE
		begin_12++
	}	while(0)

	if (success_13 && success_15 && success_17)
	{
		success_11 = TRUE
				pos = begin_12
	}
	skipspaces(TOKEN_SEQUENCE)
	auto begin_20 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_2))
		{
			if (!(CURRENT_TOKEN == AUTO_3))
			{
				break
			}
			else 
			{
				_24 = CURRENT_TOKEN
				success_25 = TRUE
				begin_20++
				_20 = _24
			}
		}
		else 
		{
			_22 = CURRENT_TOKEN
			success_23 = TRUE
			begin_20++
			_20 = _22
		}
		success_21 = TRUE
		_18 = _20
	}	while(0)

	if (success_21)
	{
		success_19 = TRUE
				pos = begin_20
	}
	data = 
		post: _18 # token
		pre: _0 # token
		brace_expression: _14.node # rule
		name: _0 # token
	;
}
Rule(cll_function_body_call) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_6))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = cll_function_arguments(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorfunction_arguments

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_7))
	{
		errorauto_7

		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2.node # rule
}
Rule(cll_function_body_decl) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_6))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = cll_function_parameters(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorfunction_parameters

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_7))
	{
		errorauto_7

		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2.node # rule
}
Rule(cll_function_arguments) {
	bool success_1 = FALSE
	any _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array _8 = NONE
	bool success_9 = FALSE
	array _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	array shadow_14 = NONE
	array shadow_15 = NONE
	auto begin_2 = pos
	_4 = any_data(TOKEN_SEQUENCE)
	if (!(_4.status))
	{
		if (!(CURRENT_TOKEN == ID))
		{
			return {}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			begin_2++
			_2 = _6
		}
	}
	else 
	{
		success_5 = TRUE
		begin_2 += _4.token.length()
		_2 = _4.node
	}
	success_3 = TRUE
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = begin_2
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_8))
		{
			break
		}
		else 
		{
			_12 = CURRENT_TOKEN
			success_13 = TRUE
			begin_10++
			shadow_14.push(_12)
			_10.push(_12)
		}
		success_11 = TRUE
		_8 = _10
		shadow_15.push(_8)
	}
	if (success_11)
	{
		success_9 = TRUE
				begin_2 = begin_10
	}
	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	data = 
		second: shadow_15 # array
		first: _2 # any
	;
}
Rule(cll_function_parameters) {
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	auto begin_2 = pos
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	begin_2++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = begin_2
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_8))
		{
			errorauto_8

			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_6++
		shadow_8.push(_6)
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == ID))
		{
			errorid

			break
		}
		_9 = CURRENT_TOKEN
		success_10 = TRUE
		begin_6++
		shadow_11.push(_9)
	}
	if (success_7 && success_10)
	{
		success_5 = TRUE
				begin_2 = begin_6
	}
	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	data = 
		second: shadow_11 # array
		first: _2 # token
	;
}
Rule(cll_cll_function_call) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = cll_function_body_call(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorfunction_body_call

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	data = 
		body: _2.node # rule
		name: _0 # token
	;
}
Rule(cll_function_decl) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	rule val = NONE
	bool success_11 = FALSE
	Rule_result _12 = NONE
	bool success_13 = FALSE
	if (!(CURRENT_TOKEN == AUTO_9))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_4 = pos
	while (CURRENT_TOKEN == ID)
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_4++
		shadow_6.push(_4)
		success_7 = TRUE
	}
	if (!success_7)
	{
		errorid

		return {}
	}
	_2 = _4
	if (success_5)
	{
		success_3 = TRUE
				pos = begin_4
	}
	skipspaces(TOKEN_SEQUENCE)
	_8 = cll_function_body_decl(TOKEN_SEQUENCE)
	if (!(_8.status))
	{
		errorfunction_body_decl

		return {}
	}
	success_9 = TRUE
	pos += _8.token.length()
	skipspaces(TOKEN_SEQUENCE)
	auto begin_12 = pos
	do
	{
		_12 = cll_block(TOKEN_SEQUENCE)
		if (!(_12.status))
		{
			errorblock

			break
		}
		success_13 = TRUE
		begin_12 += _12.token.length()
		_10 = _12.node
	}	while(0)

	if (success_13)
	{
		success_11 = TRUE
		val = _10
		pos = begin_12
	}
	data = 
		value: val # rule
		name: _2 # token
		type: shadow_6 # array
	;
}
Rule(cll_expr_logical) {
	rule _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	token _10 = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	Rule_result _14 = NONE
	bool success_15 = FALSE
	Rule_result _16 = NONE
	bool success_17 = FALSE
	Rule_result _18 = NONE
	bool success_19 = FALSE
	Rule_result _20 = NONE
	bool success_21 = FALSE
	_2 = cll_expr_compare(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		_4 = cll_expr_arithmetic(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			_6 = cll_expr_term(TOKEN_SEQUENCE)
			if (!(_6.status))
			{
				_8 = cll_expr_value(TOKEN_SEQUENCE)
				if (!(_8.status))
				{
					return {}
				}
				else 
				{
					success_9 = TRUE
					pos += _8.token.length()
					_0 = _8.node
				}
			}
			else 
			{
				success_7 = TRUE
				pos += _6.token.length()
				_0 = _6.node
			}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		success_3 = TRUE
		pos += _2.token.length()
		_0 = _2.node
	}
	success_1 = TRUE
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == cll_LOGICAL_OP))
	{
		errorlogical_op

		return {}
	}
	_10 = CURRENT_TOKEN
	success_11 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_14 = cll_expr_compare(TOKEN_SEQUENCE)
	if (!(_14.status))
	{
		_16 = cll_expr_arithmetic(TOKEN_SEQUENCE)
		if (!(_16.status))
		{
			_18 = cll_expr_term(TOKEN_SEQUENCE)
			if (!(_18.status))
			{
				_20 = cll_expr_value(TOKEN_SEQUENCE)
				if (!(_20.status))
				{
					return {}
				}
				else 
				{
					success_21 = TRUE
					pos += _20.token.length()
					_12 = _20.node
				}
			}
			else 
			{
				success_19 = TRUE
				pos += _18.token.length()
				_12 = _18.node
			}
		}
		else 
		{
			success_17 = TRUE
			pos += _16.token.length()
			_12 = _16.node
		}
	}
	else 
	{
		success_15 = TRUE
		pos += _14.token.length()
		_12 = _14.node
	}
	success_13 = TRUE
	data = 
		right: _12 # rule
		op: _10 # token
		left: _0 # rule
	;
}
Rule(cll_expr_compare) {
	rule _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	array _6 = NONE
	bool success_7 = FALSE
	bool success_14 = FALSE
	array _8 = NONE
	bool success_9 = FALSE
	token _10 = NONE
	bool success_11 = FALSE
	array shadow_12 = NONE
	array shadow_13 = NONE
	_2 = cll_expr_arithmetic(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		_4 = cll_expr_term(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			return {}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		success_3 = TRUE
		pos += _2.token.length()
		_0 = _2.node
	}
	success_1 = TRUE
	skipspaces(TOKEN_SEQUENCE)
	auto begin_8 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == cll_COMPARE_OP))
		{
			break
		}
		else 
		{
			_10 = CURRENT_TOKEN
			success_11 = TRUE
			begin_8++
			shadow_12.push(_10)
			_8.push(_10)
		}
		success_9 = TRUE
		_6 = _8
		shadow_13.push(_6)
		success_14 = TRUE
	}
	if (!success_14)
	{
		errorcompare_op

		return {}
	}
	if (success_9)
	{
		success_7 = TRUE
				pos = begin_8
	}
	data = 
		sequence: shadow_13 # array
		operators: _8 # array
		first: _0 # rule
	;
}
Rule(cll_expr_arithmetic) {
	Rule_result _0 = NONE
	bool success_1 = FALSE
	bool success_3 = FALSE
	bool success_15 = FALSE
	array _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	Rule_result _12 = NONE
	bool success_13 = FALSE
	array shadow_14 = NONE
	_0 = cll_expr_term(TOKEN_SEQUENCE)
	if (!(_0.status))
	{
		return {}
	}
	success_1 = TRUE
	pos += _0.token.length()
	skipspaces(TOKEN_SEQUENCE)
	auto begin_4 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == MINUS))
		{
			if (!(CURRENT_TOKEN == PLUS))
			{
				break
			}
			else 
			{
				_9 = CURRENT_TOKEN
				success_10 = TRUE
				begin_4++
				shadow_11.push(_9)
				_4.push(_9)
			}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			begin_4++
			shadow_8.push(_6)
			_4.push(_6)
		}
		success_5 = TRUE
		skipspaces(TOKEN_SEQUENCE)
		_12 = cll_expr_term(TOKEN_SEQUENCE)
		if (!(_12.status))
		{
			errorterm

			break
		}
		success_13 = TRUE
		begin_4 += _12.token.length()
		shadow_14.push(_12.node)
		success_15 = TRUE
	}
	if (!success_15)
	{
		errorminus or plus

		return {}
	}
	if (success_5 && success_13)
	{
		success_3 = TRUE
				pos = begin_4
	}
	data = 
		sequence: shadow_14 # array
		operators: _4 # array
		first: _0.node # rule
	;
}
Rule(cll_expr_term) {
	Rule_result _0 = NONE
	bool success_1 = FALSE
	bool success_3 = FALSE
	bool success_18 = FALSE
	array _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	token _12 = NONE
	bool success_13 = FALSE
	array shadow_14 = NONE
	Rule_result _15 = NONE
	bool success_16 = FALSE
	array shadow_17 = NONE
	_0 = cll_expr_value(TOKEN_SEQUENCE)
	if (!(_0.status))
	{
		return {}
	}
	success_1 = TRUE
	pos += _0.token.length()
	skipspaces(TOKEN_SEQUENCE)
	auto begin_4 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == DIVIDE))
		{
			if (!(CURRENT_TOKEN == MULTIPLE))
			{
				if (!(CURRENT_TOKEN == MODULO))
				{
					break
				}
				else 
				{
					_12 = CURRENT_TOKEN
					success_13 = TRUE
					begin_4++
					shadow_14.push(_12)
					_4.push(_12)
				}
			}
			else 
			{
				_9 = CURRENT_TOKEN
				success_10 = TRUE
				begin_4++
				shadow_11.push(_9)
				_4.push(_9)
			}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			begin_4++
			shadow_8.push(_6)
			_4.push(_6)
		}
		success_5 = TRUE
		skipspaces(TOKEN_SEQUENCE)
		_15 = cll_expr_value(TOKEN_SEQUENCE)
		if (!(_15.status))
		{
			errorvalue

			break
		}
		success_16 = TRUE
		begin_4 += _15.token.length()
		shadow_17.push(_15.node)
		success_18 = TRUE
	}
	if (!success_18)
	{
		errordivide or multiple or modulo

		return {}
	}
	if (success_5 && success_16)
	{
		success_3 = TRUE
				pos = begin_4
	}
	data = 
		sequence: shadow_17 # array
		operators: _4 # array
		first: _0.node # rule
	;
}
Rule(cll_expr_value) {
	rule _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	_2 = cll_variable(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		_4 = cll_expr_group(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			_6 = any_data(TOKEN_SEQUENCE)
			if (!(_6.status))
			{
				_8 = cll_cll_function_call(TOKEN_SEQUENCE)
				if (!(_8.status))
				{
					return {}
				}
				else 
				{
					success_9 = TRUE
					pos += _8.token.length()
					_0 = _8.node
				}
			}
			else 
			{
				success_7 = TRUE
				pos += _6.token.length()
				_0 = _6.node
			}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		success_3 = TRUE
		pos += _2.token.length()
		_0 = _2.node
	}
	success_1 = TRUE
	data = _0 # rule
}
Rule(cll_expr_group) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_6))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = cll_expr(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorexpr

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_7))
	{
		errorauto_7

		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2.node # rule
}
Rule(cll_expr) {
	any _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	Rule_result _10 = NONE
	bool success_11 = FALSE
	Rule_result _12 = NONE
	bool success_13 = FALSE
	if (!(CURRENT_TOKEN == AT))
	{
		_4 = cll_expr_logical(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			_6 = cll_expr_compare(TOKEN_SEQUENCE)
			if (!(_6.status))
			{
				_8 = cll_expr_arithmetic(TOKEN_SEQUENCE)
				if (!(_8.status))
				{
					_10 = cll_expr_term(TOKEN_SEQUENCE)
					if (!(_10.status))
					{
						_12 = cll_expr_value(TOKEN_SEQUENCE)
						if (!(_12.status))
						{
							return {}
						}
						else 
						{
							success_13 = TRUE
							pos += _12.token.length()
							_0 = _12.node
						}
					}
					else 
					{
						success_11 = TRUE
						pos += _10.token.length()
						_0 = _10.node
					}
				}
				else 
				{
					success_9 = TRUE
					pos += _8.token.length()
					_0 = _8.node
				}
			}
			else 
			{
				success_7 = TRUE
				pos += _6.token.length()
				_0 = _6.node
			}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		_2 = CURRENT_TOKEN
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
	data = _0 # any
}
Rule(cll_var) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	if (CURRENT_TOKEN == cll_TYPE)
	{
		_0 = CURRENT_TOKEN
		success_1 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		errorid

		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = pos
	do
	{
		if (!(CURRENT_TOKEN == cll_ASSIGNMENT_OP))
		{
			errorassignment_op

			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_6++
		skipspaces(TOKEN_SEQUENCE)
		_8 = cll_expr(TOKEN_SEQUENCE)
		if (!(_8.status))
		{
			errorexpr

			break
		}
		success_9 = TRUE
		begin_6 += _8.token.length()
	}	while(0)

	if (success_7 && success_9)
	{
		success_5 = TRUE
				pos = begin_6
	}
	data = 
		value: _8.node # rule
		op: _6 # token
		id: _2 # token
		type: _0 # token
	;
}
Rule(cll_block) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	array shadow_4 = NONE
	token _5 = NONE
	bool success_6 = FALSE
	if (!(CURRENT_TOKEN == AUTO_10))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = Rule_rule(TOKEN_SEQUENCE)
	while (_2.status)
	{
		success_3 = TRUE
		pos += _2.token.length()
		shadow_4.push(_2.node)
		_2 = Rule_rule(TOKEN_SEQUENCE)
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_11))
	{
		errorauto_11

		return {}
	}
	_5 = CURRENT_TOKEN
	success_6 = TRUE
	pos++
	data = shadow_4 # array
}
Rule(cll_loop_while) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_12))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = cll_expr(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorexpr

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(TOKEN_SEQUENCE)
	_4 = cll_block(TOKEN_SEQUENCE)
	if (!(_4.status))
	{
		errorblock

		return {}
	}
	success_5 = TRUE
	pos += _4.token.length()
	data = 
		block: _4.node # rule
		expr: _2.node # rule
	;
}
Rule(cll_loop_for) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	Rule_result _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	Rule_result _14 = NONE
	bool success_15 = FALSE
	token _16 = NONE
	bool success_17 = FALSE
	Rule_result _18 = NONE
	bool success_19 = FALSE
	token _20 = NONE
	bool success_21 = FALSE
	Rule_result _22 = NONE
	bool success_23 = FALSE
	if (!(CURRENT_TOKEN == AUTO_13))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_6))
	{
		errorauto_6

		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = pos
	do
	{
		_8 = cll_expr(TOKEN_SEQUENCE)
		if (!(_8.status))
		{
			_10 = cll_var(TOKEN_SEQUENCE)
			if (!(_10.status))
			{
				break
			}
			else 
			{
				success_11 = TRUE
				begin_6 += _10.token.length()
				_6 = _10.node
			}
		}
		else 
		{
			success_9 = TRUE
			begin_6 += _8.token.length()
			_6 = _8.node
		}
		success_7 = TRUE
		_4 = _6
	}	while(0)

	if (success_7)
	{
		success_5 = TRUE
				pos = begin_6
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_14))
	{
		errorauto_14

		return {}
	}
	_12 = CURRENT_TOKEN
	success_13 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_14 = cll_expr(TOKEN_SEQUENCE)
	if (_14.status)
	{
		success_15 = TRUE
		pos += _14.token.length()
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_14))
	{
		errorauto_14

		return {}
	}
	_16 = CURRENT_TOKEN
	success_17 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_18 = cll_expr(TOKEN_SEQUENCE)
	if (_18.status)
	{
		success_19 = TRUE
		pos += _18.token.length()
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_7))
	{
		errorauto_7

		return {}
	}
	_20 = CURRENT_TOKEN
	success_21 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_22 = cll_block(TOKEN_SEQUENCE)
	if (!(_22.status))
	{
		errorblock

		return {}
	}
	success_23 = TRUE
	pos += _22.token.length()
	data = 
		block: _20 # token
		end: _16 # token
		cond: _12 # token
		decl: _6 # rule
	;
}
Rule(cll) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	Rule_result _10 = NONE
	bool success_11 = FALSE
	Rule_result _12 = NONE
	bool success_13 = FALSE
	token _14 = NONE
	bool success_15 = FALSE
	if (!(CURRENT_TOKEN == AUTO_0))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_4 = cll_loop_while(TOKEN_SEQUENCE)
	if (!(_4.status))
	{
		_6 = cll_loop_for(TOKEN_SEQUENCE)
		if (!(_6.status))
		{
			_8 = cll_if(TOKEN_SEQUENCE)
			if (!(_8.status))
			{
				_10 = cll_expr(TOKEN_SEQUENCE)
				if (!(_10.status))
				{
					_12 = cll_var(TOKEN_SEQUENCE)
					if (!(_12.status))
					{
						return {}
					}
					else 
					{
						success_13 = TRUE
						pos += _12.token.length()
						_2 = _12.node
					}
				}
				else 
				{
					success_11 = TRUE
					pos += _10.token.length()
					_2 = _10.node
				}
			}
			else 
			{
				success_9 = TRUE
				pos += _8.token.length()
				_2 = _8.node
			}
		}
		else 
		{
			success_7 = TRUE
			pos += _6.token.length()
			_2 = _6.node
		}
	}
	else 
	{
		success_5 = TRUE
		pos += _4.token.length()
		_2 = _4.node
	}
	success_3 = TRUE
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == END))
	{
		errorend

		return {}
	}
	_14 = CURRENT_TOKEN
	success_15 = TRUE
	pos++
}
Token(STRING) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	str _8 = NONE
	bool success_9 = FALSE
	str _10 = NONE
	bool success_11 = FALSE
	str _12 = NONE
	bool success_13 = FALSE
	str _14 = NONE
	bool success_15 = FALSE
	if (!(*pos == '\''))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	auto begin_4 = pos
	while (1)
	{
		if (!(!(*pos == '\'')))
		{
			auto begin_10 = begin_4
			do
			{
				if (!(!STRNCMP(pos, "\\")))
				{
					error"\\"

					break
				}
				_10 += CURRENT_POS_SEQUENCE
				success_11 = TRUE
				begin_10++
				skipspaces(pos)
				if (*pos == '\0')
				{
					errorany symbol

					break
				}
				_12 += CURRENT_POS_SEQUENCE
				success_13 = TRUE
				begin_10++
				_8 += _10
				_8 += _12
			}			while(0)

			if (success_11 && success_13)
			{
				success_9 = TRUE
								begin_4 = begin_10
			}
			
			if (!success_9)
			{
				break
			}
			else 
			{
				_4 = _8
			}
		}
		else 
		{
			_6 = CURRENT_POS_SEQUENCE
			success_7 = TRUE
			begin_4++
			_4 = _6
		}
		success_5 = TRUE
		_2 += _4
	}
	if (success_5)
	{
		success_3 = TRUE
				pos = begin_4
	}
	skipspaces(pos)
	if (!(*pos == '\''))
	{
		error"'"

		return {}
	}
	_14 += CURRENT_POS_SEQUENCE
	success_15 = TRUE
	pos++
	data = _2 # str
}
Token(NUMBER) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	bool success_6 = FALSE
	str _7 = NONE
	bool success_8 = FALSE
	str _9 = NONE
	bool success_10 = FALSE
	str _11 = NONE
	bool success_12 = FALSE
	bool success_13 = FALSE
	if (*pos == '+' || *pos == '-')
	{
		_0 += CURRENT_POS_SEQUENCE
		success_1 = TRUE
		pos++
	}
	skipspaces(pos)
	auto begin_4 = pos
	while ((*pos>='0' && *pos<='9'))
	{
		_4 += CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_4++
		success_6 = TRUE
	}
	if (!success_6)
	{
		error0-9 or 

		return {}
	}
	_2 += _4
	if (success_5)
	{
		success_3 = TRUE
				pos = begin_4
	}
	skipspaces(pos)
	auto begin_9 = pos
	do
	{
		if (!(*pos == '.' || *pos == ','))
		{
			error.,

			break
		}
		_9 += CURRENT_POS_SEQUENCE
		success_10 = TRUE
		begin_9++
		skipspaces(pos)
		while ((*pos>='0' && *pos<='9'))
		{
			_11 += CURRENT_POS_SEQUENCE
			success_12 = TRUE
			begin_9++
			success_13 = TRUE
		}
		if (!success_13)
		{
			error0-9 or 

			break
		}
		_7 += _9
		_7 += _11
	}	while(0)

	if (success_10 && success_12)
	{
		success_8 = TRUE
				pos = begin_9
	}
	data = 
		dec: _9 # str
		main: _4 # str
		sign: _0 # str
	;
}
Token(BOOLEAN) {
	str _0 = NONE
	str d = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	auto begin_2 = pos
	if (!(!STRNCMP(pos, "false")))
	{
		if (!(!STRNCMP(pos, "true")))
		{
			return {}
		}
		else 
		{
			_6 = CURRENT_POS_SEQUENCE
			success_7 = TRUE
			begin_2++
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_2++
		_2 = _4
	}
	success_3 = TRUE
	_0 += _2
	if (success_3)
	{
		success_1 = TRUE
		d = _0
		pos = begin_2
	}
	data = d # str
}
Rule(array) {
	token _0 = NONE
	bool success_1 = FALSE
	bool success_3 = FALSE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	token _12 = NONE
	bool success_13 = FALSE
	if (!(CURRENT_TOKEN == AUTO_4))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_4 = pos
	do
	{
		auto begin_6 = begin_4
		while (1)
		{
			_6 = any_data(TOKEN_SEQUENCE)
			if (!(_6.status))
			{
				errorany_data

				break
			}
			success_7 = TRUE
			begin_6 += _6.token.length()
			shadow_8.push(_6.node)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == AUTO_8))
			{
				errorauto_8

				break
			}
			_9 = CURRENT_TOKEN
			success_10 = TRUE
			begin_6++
			shadow_11.push(_9)
		}
		if (success_7 && success_10)
		{
			success_5 = TRUE
						begin_4 = begin_6
		}
	}	while(0)

	success_3 = TRUE
		pos = begin_4
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_5))
	{
		errorauto_5

		return {}
	}
	_12 = CURRENT_TOKEN
	success_13 = TRUE
	pos++
	data = shadow_8 # array
}
Rule(object) {
	token _0 = NONE
	bool success_1 = FALSE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	array shadow_14 = NONE
	token _15 = NONE
	bool success_16 = FALSE
	array shadow_17 = NONE
	token _18 = NONE
	bool success_19 = FALSE
	array shadow_20 = NONE
	Rule_result _21 = NONE
	bool success_22 = FALSE
	array shadow_23 = NONE
	token _24 = NONE
	bool success_25 = FALSE
	token _26 = NONE
	bool success_27 = FALSE
	if (!(CURRENT_TOKEN == AUTO_10))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_4 = pos
	do
	{
		_4 = any_data(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			errorany_data

			break
		}
		success_5 = TRUE
		begin_4 += _4.token.length()
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == AUTO_15))
		{
			errorauto_15

			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_4++
		skipspaces(TOKEN_SEQUENCE)
		_8 = any_data(TOKEN_SEQUENCE)
		if (!(_8.status))
		{
			errorany_data

			break
		}
		success_9 = TRUE
		begin_4 += _8.token.length()
		skipspaces(TOKEN_SEQUENCE)
		auto begin_12 = begin_4
		while (1)
		{
			if (!(CURRENT_TOKEN == AUTO_8))
			{
				errorauto_8

				break
			}
			_12 = CURRENT_TOKEN
			success_13 = TRUE
			begin_12++
			shadow_14.push(_12)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == ID))
			{
				errorid

				break
			}
			_15 = CURRENT_TOKEN
			success_16 = TRUE
			begin_12++
			shadow_17.push(_15)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == AUTO_15))
			{
				errorauto_15

				break
			}
			_18 = CURRENT_TOKEN
			success_19 = TRUE
			begin_12++
			shadow_20.push(_18)
			skipspaces(TOKEN_SEQUENCE)
			_21 = any_data(TOKEN_SEQUENCE)
			if (!(_21.status))
			{
				errorany_data

				break
			}
			success_22 = TRUE
			begin_12 += _21.token.length()
			shadow_23.push(_21.node)
		}
		if (success_13 && success_16 && success_19 && success_22)
		{
			success_11 = TRUE
						begin_4 = begin_12
		}
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == AUTO_14))
		{
			errorauto_14

			break
		}
		_24 = CURRENT_TOKEN
		success_25 = TRUE
		begin_4++
	}	while(0)

	if (success_5 && success_7 && success_9 && success_25)
	{
		success_3 = TRUE
				pos = begin_4
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_11))
	{
		errorauto_11

		return {}
	}
	_26 = CURRENT_TOKEN
	success_27 = TRUE
	pos++
	data = 
		values: shadow_20 # array
		keys: shadow_14 # array
		value: _8.node # rule
		key: _4.node # rule
	;
}
Rule(any_data) {
	any _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	token _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	token _14 = NONE
	bool success_15 = FALSE
	_2 = object(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		_4 = array(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			if (!(CURRENT_TOKEN == AT))
			{
				if (!(CURRENT_TOKEN == ID))
				{
					if (!(CURRENT_TOKEN == BOOLEAN))
					{
						if (!(CURRENT_TOKEN == STRING))
						{
							if (!(CURRENT_TOKEN == NUMBER))
							{
								return {}
							}
							else 
							{
								_14 = CURRENT_TOKEN
								success_15 = TRUE
								pos++
								_0 = _14
							}
						}
						else 
						{
							_12 = CURRENT_TOKEN
							success_13 = TRUE
							pos++
							_0 = _12
						}
					}
					else 
					{
						_10 = CURRENT_TOKEN
						success_11 = TRUE
						pos++
						_0 = _10
					}
				}
				else 
				{
					_8 = CURRENT_TOKEN
					success_9 = TRUE
					pos++
					_0 = _8
				}
			}
			else 
			{
				_6 = CURRENT_TOKEN
				success_7 = TRUE
				pos++
				_0 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		success_3 = TRUE
		pos += _2.token.length()
		_0 = _2.node
	}
	success_1 = TRUE
	data = _0 # any
}
Token(END) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ';' || *pos == '\n'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(NEWLINE) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '\n'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(QUESTION_MARK) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '?'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(PLUS) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '+'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(MINUS) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '-'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(DIVIDE) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '/'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(MULTIPLE) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '*'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(MODULO) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '%'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(LINEAR_COMMENT) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(!STRNCMP(pos, "//")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	while (!(*pos == '\n' && *pos != '\0'))
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
	}
}
Token(ID) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	auto begin_2 = pos
	if (!((*pos>='a' && *pos<='z') || (*pos>='A' && *pos<='Z') || *pos == '_'))
	{
		return {}
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	begin_2++
	skipspaces(pos)
	while ((*pos>='a' && *pos<='z') || (*pos>='A' && *pos<='Z') || (*pos>='0' && *pos<='9') || *pos == '_')
	{
		_4 += CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_2++
	}
	_0 += _2
	_0 += _4
	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	data = _0 # str
}
Token(SPACEMODE) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	str _8 = NONE
	bool success_9 = FALSE
	if (!(!STRNCMP(pos, "spacemode")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	if (!(!STRNCMP(pos, "skipped")))
	{
		if (!(!STRNCMP(pos, "allowed")))
		{
			if (!(!STRNCMP(pos, "mixed")))
			{
				return {}
			}
			else 
			{
				_8 = CURRENT_POS_SEQUENCE
				success_9 = TRUE
				pos++
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_POS_SEQUENCE
			success_7 = TRUE
			pos++
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_POS_SEQUENCE
		success_5 = TRUE
		pos++
		_2 = _4
	}
	success_3 = TRUE
	data = _0 # str
}
Token(NAME) {
	str _0 = NONE
	bool success_1 = FALSE
	Token_result _2 = NONE
	bool success_3 = FALSE
	if (!(!STRNCMP(pos, "name")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	_2 = ID(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorid

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	data = _2.node # token
}
Token(AT) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '@'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Rule(main) {
	any _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	if (!(CURRENT_TOKEN == SPACEMODE))
	{
		if (!(CURRENT_TOKEN == NAME))
		{
			_6 = use(TOKEN_SEQUENCE)
			if (!(_6.status))
			{
				_8 = Rule(TOKEN_SEQUENCE)
				if (!(_8.status))
				{
					return {}
				}
				else 
				{
					success_9 = TRUE
					pos += _8.token.length()
					_0 = _8.node
				}
			}
			else 
			{
				success_7 = TRUE
				pos += _6.token.length()
				_0 = _6.node
			}
		}
		else 
		{
			_4 = CURRENT_TOKEN
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_TOKEN
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
}
Rule(use_unit) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = any_data(TOKEN_SEQUENCE)
	if (_2.status)
	{
		success_3 = TRUE
		pos += _2.token.length()
	}
	data = 
		value: _2.node # rule
		name: _0 # token
	;
}
Rule(use) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	Rule_result _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	if (!(CURRENT_TOKEN == AUTO_16))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = use_unit(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorunit

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_8))
		{
			errorauto_8

			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_6++
		shadow_8.push(_6)
		skipspaces(TOKEN_SEQUENCE)
		_9 = use_unit(TOKEN_SEQUENCE)
		if (!(_9.status))
		{
			errorunit

			break
		}
		success_10 = TRUE
		begin_6 += _9.token.length()
		shadow_11.push(_9.node)
	}
	if (success_7 && success_10)
	{
		success_5 = TRUE
				pos = begin_6
	}
	data = 
		second: shadow_11 # array
		first: _2.node # rule
	;
}
Rule(Rule_rule) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	any _8 = NONE
	bool success_9 = FALSE
	token _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	token _14 = NONE
	bool success_15 = FALSE
	token _16 = NONE
	bool success_17 = FALSE
	token _18 = NONE
	bool success_19 = FALSE
	token _20 = NONE
	bool success_21 = FALSE
	token _22 = NONE
	bool success_23 = FALSE
	token _24 = NONE
	bool success_25 = FALSE
	Rule_result _26 = NONE
	bool success_27 = FALSE
	token _28 = NONE
	bool success_29 = FALSE
	Rule_result _30 = NONE
	bool success_31 = FALSE
	Rule_result _32 = NONE
	bool success_33 = FALSE
	Rule_result _34 = NONE
	bool success_35 = FALSE
	auto begin_2 = pos
	do
	{
		_4 = Rule_keyvalue(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			_6 = Rule_value(TOKEN_SEQUENCE)
			if (!(_6.status))
			{
				break
			}
			else 
			{
				success_7 = TRUE
				begin_2 += _6.token.length()
				_2 = _6.node
			}
		}
		else 
		{
			success_5 = TRUE
			begin_2 += _4.token.length()
			_2 = _4.node
		}
		success_3 = TRUE
		_0 = _2
	}	while(0)

	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == Rule_NOSPACE))
	{
		if (!(CURRENT_TOKEN == Rule_ESCAPED))
		{
			if (!(CURRENT_TOKEN == Rule_HEX))
			{
				if (!(CURRENT_TOKEN == Rule_BIN))
				{
					if (!(CURRENT_TOKEN == LINEAR_COMMENT))
					{
						if (!(CURRENT_TOKEN == Rule_OP))
						{
							if (!(CURRENT_TOKEN == Rule_CSEQUENCE))
							{
								if (!(CURRENT_TOKEN == AUTO_18))
								{
									_26 = Rule_group(TOKEN_SEQUENCE)
									if (!(_26.status))
									{
										if (!(CURRENT_TOKEN == STRING))
										{
											_30 = cll(TOKEN_SEQUENCE)
											if (!(_30.status))
											{
												_32 = Rule_name(TOKEN_SEQUENCE)
												if (!(_32.status))
												{
													return {}
												}
												else 
												{
													success_33 = TRUE
													pos += _32.token.length()
													_8 = _32.node
												}
											}
											else 
											{
												success_31 = TRUE
												pos += _30.token.length()
												_8 = _30.node
											}
										}
										else 
										{
											_28 = CURRENT_TOKEN
											success_29 = TRUE
											pos++
											_8 = _28
										}
									}
									else 
									{
										success_27 = TRUE
										pos += _26.token.length()
										_8 = _26.node
									}
								}
								else 
								{
									_24 = CURRENT_TOKEN
									success_25 = TRUE
									pos++
									_8 = _24
								}
							}
							else 
							{
								_22 = CURRENT_TOKEN
								success_23 = TRUE
								pos++
								_8 = _22
							}
						}
						else 
						{
							_20 = CURRENT_TOKEN
							success_21 = TRUE
							pos++
							_8 = _20
						}
					}
					else 
					{
						_18 = CURRENT_TOKEN
						success_19 = TRUE
						pos++
						_8 = _18
					}
				}
				else 
				{
					_16 = CURRENT_TOKEN
					success_17 = TRUE
					pos++
					_8 = _16
				}
			}
			else 
			{
				_14 = CURRENT_TOKEN
				success_15 = TRUE
				pos++
				_8 = _14
			}
		}
		else 
		{
			_12 = CURRENT_TOKEN
			success_13 = TRUE
			pos++
			_8 = _12
		}
	}
	else 
	{
		_10 = CURRENT_TOKEN
		success_11 = TRUE
		pos++
		_8 = _10
	}
	success_9 = TRUE
	skipspaces(TOKEN_SEQUENCE)
	_34 = Rule_quantifier(TOKEN_SEQUENCE)
	if (_34.status)
	{
		success_35 = TRUE
		pos += _34.token.length()
	}
	data = 
		quantifier: _8 # any
		val: _0 # rule
		prefix: _2 # rule
	;
}
Rule(Rule_name) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	if (CURRENT_TOKEN == AUTO_17)
	{
		_0 = CURRENT_TOKEN
		success_1 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		errorid

		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_18))
		{
			errorauto_18

			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_6++
		shadow_8.push(_6)
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == ID))
		{
			errorid

			break
		}
		_9 = CURRENT_TOKEN
		success_10 = TRUE
		begin_6++
		shadow_11.push(_9)
	}
	if (success_7 && success_10)
	{
		success_5 = TRUE
				pos = begin_6
	}
	data = 
		nested_name: shadow_11 # array
		name: _2 # token
		is_nested: _0 # token
	;
}
Rule(Rule_group) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	array shadow_4 = NONE
	token _5 = NONE
	bool success_6 = FALSE
	if (!(CURRENT_TOKEN == AUTO_6))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = Rule_rule(TOKEN_SEQUENCE)
	while (_2.status)
	{
		success_3 = TRUE
		pos += _2.token.length()
		shadow_4.push(_2.node)
		_2 = Rule_rule(TOKEN_SEQUENCE)
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_7))
	{
		errorauto_7

		return {}
	}
	_5 = CURRENT_TOKEN
	success_6 = TRUE
	pos++
	data = shadow_4 # array
}
Rule(Rule_keyvalue) {
	token _0 = NONE
	bool success_1 = FALSE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AT))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	auto begin_4 = pos
	do
	{
		if (!(CURRENT_TOKEN == ID))
		{
			errorid

			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_4++
	}	while(0)

	if (success_5)
	{
		success_3 = TRUE
				pos = begin_4
	}
	data = _4 # token
}
Rule(Rule_value) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == AUTO_19))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		errorid

		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	data = _2 # token
}
Rule(Rule_nested_rule) {
	token _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	if (CURRENT_TOKEN == AUTO_17)
	{
		_0 = CURRENT_TOKEN
		success_1 = TRUE
		pos++
	}
	_2 = Rule(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		errorrule

		return {}
	}
	success_3 = TRUE
	pos += _2.token.length()
	data = _2.node # rule
}
Rule(Rule_data_block_regular_datablock_key) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	token name = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	rule dt = NONE
	bool success_11 = FALSE
	Rule_result _12 = NONE
	bool success_13 = FALSE
	while (CURRENT_TOKEN == AUTO_20)
	{
		_0 = CURRENT_TOKEN
		success_1 = TRUE
		pos++
		shadow_2.push(_0)
		success_3 = TRUE
	}
	if (!success_3)
	{
		return {}
	}
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = pos
	if (!(CURRENT_TOKEN == ID))
	{
		errorid

		return {}
	}
	_6 = CURRENT_TOKEN
	success_7 = TRUE
	begin_6++
	_4 = _6
	if (success_7)
	{
		success_5 = TRUE
		name = _4
		pos = begin_6
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_21))
	{
		errorauto_21

		return {}
	}
	_8 = CURRENT_TOKEN
	success_9 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_12 = pos
	_12 = cll_expr(TOKEN_SEQUENCE)
	if (!(_12.status))
	{
		errorcll

		return {}
	}
	success_13 = TRUE
	begin_12 += _12.token.length()
	_10 = _12.node
	if (success_13)
	{
		success_11 = TRUE
		dt = _10
		pos = begin_12
	}
	data = 
		val: dt # rule
		name: name # token
	;
}
Rule(Rule_data_block_regular_datablock) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	Rule_result _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	if (!(CURRENT_TOKEN == AUTO_10))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_4 = Rule_data_block_regular_datablock_key(TOKEN_SEQUENCE)
	if (!(_4.status))
	{
		_6 = any_data(TOKEN_SEQUENCE)
		if (!(_6.status))
		{
			return {}
		}
		else 
		{
			success_7 = TRUE
			pos += _6.token.length()
			_2 = _6.node
		}
	}
	else 
	{
		success_5 = TRUE
		pos += _4.token.length()
		_2 = _4.node
	}
	success_3 = TRUE
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_11))
	{
		errorauto_11

		return {}
	}
	_8 = CURRENT_TOKEN
	success_9 = TRUE
	pos++
	data = _2 # rule
}
Rule(Rule_data_block_templated_datablock) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	bool success_5 = FALSE
	token _6 = NONE
	token first_name = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	array shadow_14 = NONE
	token _15 = NONE
	array second_name = NONE
	bool success_16 = FALSE
	token _17 = NONE
	bool success_18 = FALSE
	array shadow_19 = NONE
	array shadow_20 = NONE
	token _21 = NONE
	bool success_22 = FALSE
	if (!(CURRENT_TOKEN == AT))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_10))
	{
		errorauto_10

		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_6 = pos
	do
	{
		auto begin_8 = begin_6
		if (!(CURRENT_TOKEN == ID))
		{
			errorid

			break
		}
		_8 = CURRENT_TOKEN
		success_9 = TRUE
		begin_8++
		_6 = _8
		if (success_9)
		{
			success_7 = TRUE
			first_name = _6
			begin_6 = begin_8
		}
		skipspaces(TOKEN_SEQUENCE)
		auto begin_12 = begin_6
		while (1)
		{
			if (!(CURRENT_TOKEN == AUTO_8))
			{
				errorauto_8

				break
			}
			_12 = CURRENT_TOKEN
			success_13 = TRUE
			begin_12++
			shadow_14.push(_12)
			skipspaces(TOKEN_SEQUENCE)
			auto begin_17 = begin_12
			if (!(CURRENT_TOKEN == ID))
			{
				errorid

				break
			}
			_17 = CURRENT_TOKEN
			success_18 = TRUE
			begin_17++
			shadow_19.push(_17)
			_15 = _17
			shadow_20.push(_15)
			if (success_18)
			{
				success_16 = TRUE
				second_name = shadow_20
				begin_12 = begin_17
			}
		}
		if (success_13 && success_16)
		{
			success_11 = TRUE
						begin_6 = begin_12
		}
	}	while(0)

	if (success_7)
	{
		success_5 = TRUE
				pos = begin_6
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_11))
	{
		errorauto_11

		return {}
	}
	_21 = CURRENT_TOKEN
	success_22 = TRUE
	pos++
	data = 
		second_name: second_name # array
		first_name: first_name # token
	;
}
Rule(Rule_data_block) {
	rule _0 = NONE
	bool success_1 = FALSE
	Rule_result _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	_2 = Rule_data_block_regular_datablock(TOKEN_SEQUENCE)
	if (!(_2.status))
	{
		_4 = Rule_data_block_templated_datablock(TOKEN_SEQUENCE)
		if (!(_4.status))
		{
			return {}
		}
		else 
		{
			success_5 = TRUE
			pos += _4.token.length()
			_0 = _4.node
		}
	}
	else 
	{
		success_3 = TRUE
		pos += _2.token.length()
		_0 = _2.node
	}
	success_1 = TRUE
	data = _0 # rule
}
Token(Rule_OP) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '|'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Rule(Rule_quantifier) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	if (!(CURRENT_TOKEN == QUESTION_MARK))
	{
		if (!(CURRENT_TOKEN == PLUS))
		{
			if (!(CURRENT_TOKEN == MULTIPLE))
			{
				return {}
			}
			else 
			{
				_6 = CURRENT_TOKEN
				success_7 = TRUE
				pos++
				_0 = _6
			}
		}
		else 
		{
			_4 = CURRENT_TOKEN
			success_5 = TRUE
			pos++
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_TOKEN
		success_3 = TRUE
		pos++
		_0 = _2
	}
	success_1 = TRUE
	data = _0 # token
}
Token(Rule_CSEQUENCE_SYMBOL) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	str _8 = NONE
	bool success_9 = FALSE
	auto begin_2 = pos
	if (!(!STRNCMP(pos, "\\]")))
	{
		if (!(!STRNCMP(pos, "\\")))
		{
			if (!(!(*pos == ']')))
			{
				return {}
			}
			else 
			{
				_8 = CURRENT_POS_SEQUENCE
				success_9 = TRUE
				begin_2++
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_POS_SEQUENCE
			success_7 = TRUE
			begin_2++
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_2++
		_2 = _4
	}
	success_3 = TRUE
	_0 += _2
	if (success_3)
	{
		success_1 = TRUE
				pos = begin_2
	}
	data = _0 # str
}
Token(Rule_CSEQUENCE_ESCAPE) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	if (!(!STRNCMP(pos, "\\")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	auto begin_4 = pos
	if (*pos == '\0')
	{
		errorany symbol

		return {}
	}
	_4 += CURRENT_POS_SEQUENCE
	success_5 = TRUE
	begin_4++
	_2 += _4
	if (success_5)
	{
		success_3 = TRUE
				pos = begin_4
	}
	data = _2 # str
}
Token(Rule_CSEQUENCE_DIAPASON) {
	bool success_1 = FALSE
	token _2 = NONE
	token from = NONE
	bool success_3 = FALSE
	Token_result _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	token to = NONE
	bool success_9 = FALSE
	Token_result _10 = NONE
	bool success_11 = FALSE
	auto begin_2 = pos
	auto begin_4 = begin_2
	_4 = Rule_CSEQUENCE_SYMBOL(TOKEN_SEQUENCE)
	if (!(_4.status))
	{
		return {}
	}
	success_5 = TRUE
	begin_4 += _4.token.length()
	_2 = _4.node
	if (success_5)
	{
		success_3 = TRUE
		from = _2
		begin_2 = begin_4
	}
	if (!(*pos == '-'))
	{
		error"-"

		return {}
	}
	_6 += CURRENT_POS_SEQUENCE
	success_7 = TRUE
	begin_2++
	auto begin_10 = begin_2
	_10 = Rule_CSEQUENCE_SYMBOL(TOKEN_SEQUENCE)
	if (!(_10.status))
	{
		errorsymbol

		return {}
	}
	success_11 = TRUE
	begin_10 += _10.token.length()
	_8 = _10.node
	if (success_11)
	{
		success_9 = TRUE
		to = _8
		begin_2 = begin_10
	}
	if (success_3 && success_7 && success_9)
	{
		success_1 = TRUE
				pos = begin_2
	}
	data = [from,to,] # array
}
Token(Rule_CSEQUENCE) {
	Token_result _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	array _4 = NONE
	array dt = NONE
	bool success_5 = FALSE
	array _6 = NONE
	bool success_7 = FALSE
	Token_result _8 = NONE
	bool success_9 = FALSE
	array shadow_10 = NONE
	Token_result _11 = NONE
	bool success_12 = FALSE
	array shadow_13 = NONE
	Token_result _14 = NONE
	bool success_15 = FALSE
	array shadow_16 = NONE
	array shadow_17 = NONE
	Token_result _18 = NONE
	bool success_19 = FALSE
	_0 = AUTO_4(TOKEN_SEQUENCE)
	if (!(_0.status))
	{
		return {}
	}
	success_1 = TRUE
	pos += _0.token.length()
	skipspaces(pos)
	if (*pos == '^')
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
	}
	skipspaces(pos)
	auto begin_6 = pos
	while (1)
	{
		_8 = Rule_CSEQUENCE_DIAPASON(TOKEN_SEQUENCE)
		if (!(_8.status))
		{
			_11 = Rule_CSEQUENCE_SYMBOL(TOKEN_SEQUENCE)
			if (!(_11.status))
			{
				_14 = Rule_CSEQUENCE_ESCAPE(TOKEN_SEQUENCE)
				if (!(_14.status))
				{
					break
				}
				else 
				{
					success_15 = TRUE
					begin_6 += _14.token.length()
					shadow_16.push(_14.node)
					_6.push(_14.node)
				}
			}
			else 
			{
				success_12 = TRUE
				begin_6 += _11.token.length()
				shadow_13.push(_11.node)
				_6.push(_11.node)
			}
		}
		else 
		{
			success_9 = TRUE
			begin_6 += _8.token.length()
			shadow_10.push(_8.node)
			_6.push(_8.node)
		}
		success_7 = TRUE
		_4 = _6
		shadow_17.push(_4)
	}
	if (success_7)
	{
		success_5 = TRUE
		dt = shadow_17
		pos = begin_6
	}
	skipspaces(pos)
	_18 = AUTO_5(TOKEN_SEQUENCE)
	if (!(_18.status))
	{
		error"]"

		return {}
	}
	success_19 = TRUE
	pos += _18.token.length()
	data = 
		val: dt # array
		_not: _2 # str
	;
}
Token(Rule_NOSPACE) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "\\s0")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(Rule_ESCAPED) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	if (!(!STRNCMP(pos, "\\")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	auto begin_4 = pos
	if (*pos == '\0')
	{
		errorany symbol

		return {}
	}
	_4 += CURRENT_POS_SEQUENCE
	success_5 = TRUE
	begin_4++
	_2 += _4
	if (success_5)
	{
		success_3 = TRUE
				pos = begin_4
	}
	data = _2 # str
}
Token(Rule_HEX) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	bool success_4 = FALSE
	if (!(!STRNCMP(pos, "0x")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	while ((*pos>='0' && *pos<='9') || (*pos>='A' && *pos<='F') || (*pos>='a' && *pos<='f'))
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		success_4 = TRUE
	}
	if (!success_4)
	{
		error0-9 or A-Fa-f

		return {}
	}
	data = _2 # str
}
Token(Rule_BIN) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	bool success_4 = FALSE
	if (!(!STRNCMP(pos, "0b")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	while (*pos == '0' || *pos == '1')
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		pos++
		success_4 = TRUE
	}
	if (!success_4)
	{
		error01

		return {}
	}
	data = _2 # str
}
Rule(Rule) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	Rule_result _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	bool success_7 = FALSE
	Rule_result _8 = NONE
	bool success_9 = FALSE
	Rule_result _10 = NONE
	bool success_11 = FALSE
	array shadow_12 = NONE
	token _13 = NONE
	bool success_14 = FALSE
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_15))
	{
		errorauto_15

		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_4 = Rule_rule(TOKEN_SEQUENCE)
	while (_4.status)
	{
		success_5 = TRUE
		pos += _4.token.length()
		shadow_6.push(_4.node)
		_4 = Rule_rule(TOKEN_SEQUENCE)
		success_7 = TRUE
	}
	if (!success_7)
	{
		errorrule

		return {}
	}
	skipspaces(TOKEN_SEQUENCE)
	_8 = Rule_data_block(TOKEN_SEQUENCE)
	if (_8.status)
	{
		success_9 = TRUE
		pos += _8.token.length()
	}
	skipspaces(TOKEN_SEQUENCE)
	_10 = Rule_nested_rule(TOKEN_SEQUENCE)
	while (_10.status)
	{
		success_11 = TRUE
		pos += _10.token.length()
		shadow_12.push(_10.node)
		_10 = Rule_nested_rule(TOKEN_SEQUENCE)
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_14))
	{
		error";"

		return {}
	}
	_13 = CURRENT_TOKEN
	success_14 = TRUE
	pos++
	data = 
		nested_rules: shadow_12 # array
		data_block: _8.node # rule
		rule: shadow_6 # array
		name: _0 # token
	;
}
Token(AUTO_0) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '$'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_1) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "if")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_2) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "--")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_3) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "++")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_4) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '['))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_5) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ']'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_6) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '('))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_7) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ')'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_8) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ','))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_9) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "fn")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_10) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '{'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_11) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '}'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_12) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "while")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_13) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "for")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_14) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ';'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_15) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ':'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_16) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "use")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_17) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '#'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_18) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '.'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_19) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '&'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_20) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '\n' || *pos == '\r'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_21) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '='))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(__WHITESPACE) {
	str _0 = NONE
	bool success_1 = FALSE
	bool success_2 = FALSE
	while (*pos == ' ' || *pos == '\t' || *pos == '\n' || *pos == '\r' || *pos == '\v' || *pos == '\f')
	{
		_0 += CURRENT_POS_SEQUENCE
		success_1 = TRUE
		pos++
		success_2 = TRUE
	}
	if (!success_2)
	{
		return {}
	}
}
