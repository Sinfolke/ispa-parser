Rule(accessor_group) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == AUTO_4))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == NUMBER))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	data = _2 # token
}
Rule(accessor_element) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == AUTO_1))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == NUMBER))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	data = _2 # token
}
Rule(accessor_char) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == AUTO_91))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == NUMBER))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	data = _2 # token
}
Rule(accessor_all) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	_2 = accessor_group(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		_4 = accessor_element(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			_6 = accessor_char(TOKEN_SEQUENCE)
			if (!(_6.res))
			{
				return {}
			}
			else 
			{
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # rule
}
Rule(accessor) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = accessor_all(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_3))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = accessor_all(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = 
		second: _7 # rule
		first: _0 # rule
	;
}
Rule(cll) {
	token cll_begin = NONE
	bool success_0 = FALSE
	token _1 = NONE
	bool success_2 = FALSE
	array shadow_37 = NONE
	str _4 = NONE
	bool success_5 = FALSE
	bool success_38 = FALSE
	array shadow_32 = NONE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	array shadow_12 = NONE
	rule _13 = NONE
	bool success_14 = FALSE
	array shadow_15 = NONE
	rule _16 = NONE
	bool success_17 = FALSE
	array shadow_18 = NONE
	rule _19 = NONE
	bool success_20 = FALSE
	array shadow_21 = NONE
	rule _22 = NONE
	bool success_23 = FALSE
	array shadow_24 = NONE
	rule _25 = NONE
	bool success_26 = FALSE
	array shadow_27 = NONE
	rule _28 = NONE
	bool success_29 = FALSE
	array shadow_30 = NONE
	token _33 = NONE
	bool success_34 = FALSE
	array shadow_35 = NONE
	auto begin_3 = pos
	if (!(CURRENT_TOKEN == AUTO_4))
	{
		return {}
	}
	_1 = CURRENT_TOKEN
	success_2 = TRUE
	begin_3++
	if (success_2)
	{
		success_0 = TRUE
		pos = begin_3
	}
	cll_begin = _1
	skipspaces(TOKEN_SEQUENCE)
	auto begin_36 = pos
	while (1)
	{
		auto begin_31 = begin_36
		while (1)
		{
			_10 = cll_var(TOKEN_SEQUENCE)
			if (!(_10.res))
			{
				_13 = cll_if(TOKEN_SEQUENCE)
				if (!(_13.res))
				{
					_16 = expr(TOKEN_SEQUENCE)
					if (!(_16.res))
					{
						_19 = copiable_method_call(TOKEN_SEQUENCE)
						if (!(_19.res))
						{
							_22 = method_call(TOKEN_SEQUENCE)
							if (!(_22.res))
							{
								_25 = loop_while(TOKEN_SEQUENCE)
								if (!(_25.res))
								{
									_28 = loop_for(TOKEN_SEQUENCE)
									if (!(_28.res))
									{
										break
									}
									else 
									{
										success_29 = TRUE
										shadow_30.push(_28)
										_8 = _28
									}
								}
								else 
								{
									success_26 = TRUE
									shadow_27.push(_25)
									_8 = _25
								}
							}
							else 
							{
								success_23 = TRUE
								shadow_24.push(_22)
								_8 = _22
							}
						}
						else 
						{
							success_20 = TRUE
							shadow_21.push(_19)
							_8 = _19
						}
					}
					else 
					{
						success_17 = TRUE
						shadow_18.push(_16)
						_8 = _16
					}
				}
				else 
				{
					success_14 = TRUE
					shadow_15.push(_13)
					_8 = _13
				}
			}
			else 
			{
				success_11 = TRUE
				shadow_12.push(_10)
				_8 = _10
			}
			_8 += CURRENT_POS_SEQUENCE
			success_9 = TRUE
			begin_31++
			shadow_32.push(_6)
		}
		if (success_9)
		{
			success_7 = TRUE
			begin_36 = begin_31
		}
		_6 = _8
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == END))
		{
			break
		}
		_33 = CURRENT_TOKEN
		success_34 = TRUE
		begin_36++
		shadow_35.push(_33)
		shadow_37.push(_4)
		success_38 = TRUE
	}
	if (!success_38)
	{
		return {}
	}
	if (success_34)
	{
		success_5 = TRUE
		pos = begin_36
	}
	_4 += shadow_32
	_4 += shadow_35
	data = shadow_37 # array
}
Rule(cll_block) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_65))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = Rule_rule(TOKEN_SEQUENCE)
	while (_2.res)
	{
		success_3 = TRUE
		pos++
		_2 = Rule_rule(TOKEN_SEQUENCE)
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_70))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2 # rule
}
Rule(cll_spaced_block) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_2 = NONE
	while ((skipup(" ")>spaces_amount))
	{
		_0 = Rule_rule(TOKEN_SEQUENCE)
		if (!(_0.res))
		{
			return {}
		}
		success_1 = TRUE
		pos++
		shadow_2.push(_0)
		skipspaces(TOKEN_SEQUENCE)
	}
	data = _0 # rule
}
Token(OP) {
	any _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(*pos == '+'))
	{
		str _4 = NONE
		bool success_5 = FALSE
		if (!(*pos == '-'))
		{
			str _6 = NONE
			bool success_7 = FALSE
			if (!(*pos == '*'))
			{
				str _8 = NONE
				bool success_9 = FALSE
				if (!(*pos == '/'))
				{
					str _10 = NONE
					bool success_11 = FALSE
					if (!(*pos == '%'))
					{
					}
					else 
					{
						_10 += CURRENT_POS_SEQUENCE
						success_11 = TRUE
						_0 = _10
					}
				}
				else 
				{
					_8 += CURRENT_POS_SEQUENCE
					success_9 = TRUE
					_0 = _8
				}
			}
			else 
			{
				_6 += CURRENT_POS_SEQUENCE
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			_4 += CURRENT_POS_SEQUENCE
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(pos)
	str _12 = NONE
	bool success_13 = FALSE
	str _14 = NONE
	bool success_15 = FALSE
	if (!(*pos == '&'))
	{
		str _16 = NONE
		bool success_17 = FALSE
		if (!(*pos == '|'))
		{
			str _18 = NONE
			bool success_19 = FALSE
			if (!(*pos == '^'))
			{
				str _20 = NONE
				bool success_21 = FALSE
				if (!(!STRNCMP(pos, "<<")))
				{
					str _22 = NONE
					bool success_23 = FALSE
					if (!(!STRNCMP(pos, ">>")))
					{
						return {}
					}
					else 
					{
						_22 += CURRENT_POS_SEQUENCE
						success_23 = TRUE
						_12 = _22
					}
				}
				else 
				{
					_20 += CURRENT_POS_SEQUENCE
					success_21 = TRUE
					_12 = _20
				}
			}
			else 
			{
				_18 += CURRENT_POS_SEQUENCE
				success_19 = TRUE
				_12 = _18
			}
		}
		else 
		{
			_16 += CURRENT_POS_SEQUENCE
			success_17 = TRUE
			_12 = _16
		}
	}
	else 
	{
		_14 += CURRENT_POS_SEQUENCE
		success_15 = TRUE
		_12 = _14
	}
	_12 += CURRENT_POS_SEQUENCE
	success_13 = TRUE
	pos++
	data = _0 # any
}
Token(ASSIGNMENT_OP) {
	token _0 = NONE
	bool success_1 = FALSE
	_0 = OP(TOKEN_SEQUENCE)
	if (_0.res)
	{
		success_1 = TRUE
		pos++
	}
	skipspaces(pos)
	token _2 = NONE
	bool success_3 = FALSE
	_2 = AUTO_55(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	data = _0 # token
}
Token(COMPARE_OP) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(!STRNCMP(pos, "==")))
	{
		str _4 = NONE
		bool success_5 = FALSE
		if (!(!STRNCMP(pos, "!=")))
		{
			str _6 = NONE
			bool success_7 = FALSE
			if (!(*pos == '>'))
			{
				str _8 = NONE
				bool success_9 = FALSE
				if (!(*pos == '<'))
				{
					str _10 = NONE
					bool success_11 = FALSE
					if (!(!STRNCMP(pos, ">=")))
					{
						str _12 = NONE
						bool success_13 = FALSE
						if (!(!STRNCMP(pos, "<=")))
						{
							return {}
						}
						else 
						{
							_12 += CURRENT_POS_SEQUENCE
							success_13 = TRUE
							_0 = _12
						}
					}
					else 
					{
						_10 += CURRENT_POS_SEQUENCE
						success_11 = TRUE
						_0 = _10
					}
				}
				else 
				{
					_8 += CURRENT_POS_SEQUENCE
					success_9 = TRUE
					_0 = _8
				}
			}
			else 
			{
				_6 += CURRENT_POS_SEQUENCE
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			_4 += CURRENT_POS_SEQUENCE
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(LOGICAL_OP) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	_2 = LOGICAL_AND(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		token _4 = NONE
		bool success_5 = FALSE
		_4 = LOGICAL_OR(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			return {}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # token
}
Token(LOGICAL_NOT) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(*pos == '!'))
	{
		str _4 = NONE
		bool success_5 = FALSE
		if (!(!STRNCMP(pos, "not")))
		{
			return {}
		}
		else 
		{
			_4 += CURRENT_POS_SEQUENCE
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(LOGICAL_AND) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(!STRNCMP(pos, "&&")))
	{
		str _4 = NONE
		bool success_5 = FALSE
		if (!(!STRNCMP(pos, "and")))
		{
			return {}
		}
		else 
		{
			_4 += CURRENT_POS_SEQUENCE
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(LOGICAL_OR) {
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(!STRNCMP(pos, "||")))
	{
		str _4 = NONE
		bool success_5 = FALSE
		if (!(!STRNCMP(pos, "or")))
		{
			return {}
		}
		else 
		{
			_4 += CURRENT_POS_SEQUENCE
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(LOGICAL_ANDR) {
	any _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	if (!(!STRNCMP(pos, "|&")))
	{
		str _4 = NONE
		bool success_5 = FALSE
		auto begin_13 = pos
		do
		{
			str _6 = NONE
			bool success_7 = FALSE
			if (!(!STRNCMP(pos, "and")))
			{
				break
			}
			_6 += CURRENT_POS_SEQUENCE
			success_7 = TRUE
			begin_13++
			array shadow_10 = NONE
			str _8 = NONE
			bool success_9 = FALSE
			if (*pos != ' ')
			{
				break
				shadow_10.push(_8)
			}
			_8 += CURRENT_POS_SEQUENCE
			success_9 = TRUE
			begin_13++
			str _11 = NONE
			bool success_12 = FALSE
			if (!(!STRNCMP(pos, "or")))
			{
				break
			}
			_11 += CURRENT_POS_SEQUENCE
			success_12 = TRUE
			begin_13++
		}		while(0)

		if (success_12)
		{
			success_5 = TRUE
			pos = begin_13
		}
		_4 += _6
		_4 += shadow_10
		_4 += _11
		if (!success_5)
		{
			return {}
		}
		else 
		{
			_0 = _4
		}
	}
	else 
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _6 # str
}
Rule(cll_template_content_typename) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = cll_type(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = cll_type(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_template_content_int) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	token _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	if (!(CURRENT_TOKEN == NUMBER))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == NUMBER))
		{
			break
		}
		_7 = CURRENT_TOKEN
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_template_content_bool) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	token _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	if (!(CURRENT_TOKEN == BOOLEAN))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == BOOLEAN))
		{
			break
		}
		_7 = CURRENT_TOKEN
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_template_content_str) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	token _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	if (!(CURRENT_TOKEN == STRING))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == STRING))
		{
			break
		}
		_7 = CURRENT_TOKEN
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_template_content_arr) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = array(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = array(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_template_content_obj) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = object(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = object(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_template_content_any_data) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = any_data(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = any_data(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = [%1
,%3
,] # array
}
Rule(cll_csupport_types) {
	bool is_unsigned = matched($1>%1
)
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	token _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	token _14 = NONE
	bool success_15 = FALSE
	token _16 = NONE
	bool success_17 = FALSE
	token _18 = NONE
	bool success_19 = FALSE
	token _22 = NONE
	bool success_23 = FALSE
	token _24 = NONE
	bool success_25 = FALSE
	token _26 = NONE
	bool success_27 = FALSE
	token _28 = NONE
	bool success_29 = FALSE
	token _31 = NONE
	bool success_32 = FALSE
	token _33 = NONE
	bool success_34 = FALSE
	token _35 = NONE
	bool success_36 = FALSE
	token _37 = NONE
	bool success_38 = FALSE
	token _39 = NONE
	bool success_40 = FALSE
	token _41 = NONE
	bool success_42 = FALSE
	token _43 = NONE
	bool success_44 = FALSE
	token _45 = NONE
	bool success_46 = FALSE
	rule _48 = NONE
	bool success_49 = FALSE
	auto begin_21 = pos
	do
	{
		if (CURRENT_TOKEN == AUTO_14)
		{
			_4 = CURRENT_TOKEN
			success_5 = TRUE
			begin_21++
		}
		skipspaces(TOKEN_SEQUENCE)
		auto begin_20 = begin_21
		if (!(CURRENT_TOKEN == AUTO_15))
		{
			if (!(CURRENT_TOKEN == AUTO_16))
			{
				if (!(CURRENT_TOKEN == AUTO_17))
				{
					if (!(CURRENT_TOKEN == AUTO_18))
					{
						if (!(CURRENT_TOKEN == AUTO_19))
						{
							break
						}
						else 
						{
							_18 = CURRENT_TOKEN
							success_19 = TRUE
							_8 = _18
						}
					}
					else 
					{
						_16 = CURRENT_TOKEN
						success_17 = TRUE
						_8 = _16
					}
				}
				else 
				{
					_14 = CURRENT_TOKEN
					success_15 = TRUE
					_8 = _14
				}
			}
			else 
			{
				_12 = CURRENT_TOKEN
				success_13 = TRUE
				_8 = _12
			}
		}
		else 
		{
			_10 = CURRENT_TOKEN
			success_11 = TRUE
			_8 = _10
		}
		_8 += CURRENT_POS_SEQUENCE
		success_9 = TRUE
		begin_20++
		if (success_9)
		{
			success_7 = TRUE
			begin_21 = begin_20
		}
		_6 = _8
	}	while(0)

	if (success_7)
	{
		success_3 = TRUE
		pos = begin_21
	}
	_2 += _4
	_2 += _6
	if (!success_3)
	{
		auto begin_30 = pos
		do
		{
			if (!(CURRENT_TOKEN == AUTO_20))
			{
				if (!(CURRENT_TOKEN == AUTO_21))
				{
					break
				}
				else 
				{
					_28 = CURRENT_TOKEN
					success_29 = TRUE
					_24 = _28
				}
			}
			else 
			{
				_26 = CURRENT_TOKEN
				success_27 = TRUE
				_24 = _26
			}
			_24 += CURRENT_POS_SEQUENCE
			success_25 = TRUE
			begin_30++
		}		while(0)

		if (success_25)
		{
			success_23 = TRUE
			pos = begin_30
		}
		_22 = _24
		if (!success_23)
		{
			auto begin_47 = pos
			do
			{
				if (!(CURRENT_TOKEN == AUTO_22))
				{
					if (!(CURRENT_TOKEN == AUTO_23))
					{
						if (!(CURRENT_TOKEN == AUTO_24))
						{
							if (!(CURRENT_TOKEN == AUTO_25))
							{
								if (!(CURRENT_TOKEN == AUTO_26))
								{
									if (!(CURRENT_TOKEN == AUTO_27))
									{
										break
									}
									else 
									{
										_45 = CURRENT_TOKEN
										success_46 = TRUE
										_33 = _45
									}
								}
								else 
								{
									_43 = CURRENT_TOKEN
									success_44 = TRUE
									_33 = _43
								}
							}
							else 
							{
								_41 = CURRENT_TOKEN
								success_42 = TRUE
								_33 = _41
							}
						}
						else 
						{
							_39 = CURRENT_TOKEN
							success_40 = TRUE
							_33 = _39
						}
					}
					else 
					{
						_37 = CURRENT_TOKEN
						success_38 = TRUE
						_33 = _37
					}
				}
				else 
				{
					_35 = CURRENT_TOKEN
					success_36 = TRUE
					_33 = _35
				}
				_33 += CURRENT_POS_SEQUENCE
				success_34 = TRUE
				begin_47++
			}			while(0)

			if (success_34)
			{
				success_32 = TRUE
				pos = begin_47
			}
			_31 = _33
			if (!success_32)
			{
				return {}
			}
			else 
			{
				_0 = _31
			}
		}
		else 
		{
			_0 = _22
		}
	}
	else 
	{
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_48 = cll_template_typename(TOKEN_SEQUENCE)
	if (!(_48.res))
	{
		return {}
	}
	success_49 = TRUE
	pos++
	data = 
		template: _8 # token
		type: _4 # token
	;
}
Rule(cll_type_abstract) {
	any _0 = NONE
	bool success_1 = FALSE
	any _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	token _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	str _14 = NONE
	bool success_15 = FALSE
	token _16 = NONE
	bool success_17 = FALSE
	rule _18 = NONE
	bool success_19 = FALSE
	str _21 = NONE
	bool success_22 = FALSE
	token _23 = NONE
	bool success_24 = FALSE
	rule _25 = NONE
	bool success_26 = FALSE
	auto begin_28 = pos
	if (!(CURRENT_TOKEN == AUTO_28))
	{
		if (!(CURRENT_TOKEN == AUTO_29))
		{
			if (!(CURRENT_TOKEN == AUTO_30))
			{
				if (!(CURRENT_TOKEN == AUTO_31))
				{
					if (!(CURRENT_TOKEN == AUTO_32))
					{
						auto begin_20 = begin_28
						do
						{
							if (!(CURRENT_TOKEN == AUTO_33))
							{
								break
							}
							_16 = CURRENT_TOKEN
							success_17 = TRUE
							begin_20++
							skipspaces(TOKEN_SEQUENCE)
							_18 = cll_template_typename(TOKEN_SEQUENCE)
							if (!(_18.res))
							{
								break
							}
							success_19 = TRUE
							begin_20++
						}						while(0)

						if (success_19)
						{
							success_15 = TRUE
							begin_28 = begin_20
						}
						_14 += _16
						_14 += _18
						if (!success_15)
						{
							auto begin_27 = begin_28
							do
							{
								if (!(CURRENT_TOKEN == AUTO_34))
								{
									break
								}
								_23 = CURRENT_TOKEN
								success_24 = TRUE
								begin_27++
								skipspaces(TOKEN_SEQUENCE)
								_25 = cll_template_typename(TOKEN_SEQUENCE)
								if (!(_25.res))
								{
									break
								}
								success_26 = TRUE
								begin_27++
							}							while(0)

							if (success_26)
							{
								success_22 = TRUE
								begin_28 = begin_27
							}
							_21 += _23
							_21 += _25
							if (!success_22)
							{
								return {}
							}
							else 
							{
								_2 = _21
							}
						}
						else 
						{
							_2 = _14
						}
					}
					else 
					{
						_12 = CURRENT_TOKEN
						success_13 = TRUE
						_2 = _12
					}
				}
				else 
				{
					_10 = CURRENT_TOKEN
					success_11 = TRUE
					_2 = _10
				}
			}
			else 
			{
				_8 = CURRENT_TOKEN
				success_9 = TRUE
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		_2 = _4
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	begin_28++
	if (success_3)
	{
		success_1 = TRUE
		pos = begin_28
	}
	data = 
		template: _18 # rule
		type: _16 # token
	;
}
Rule(cll_type) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	_2 = cll_csupport_types(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		_4 = cll_type_abstract(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			return {}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # rule
}
Rule(cll_if) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	array shadow_4 = NONE
	token _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	str _10 = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	rule _14 = NONE
	bool success_15 = FALSE
	rule _16 = NONE
	bool success_17 = FALSE
	str _18 = NONE
	bool success_19 = FALSE
	UNDEF _21 = NONE
	UNDEF shadow_22 = NONE
	bool success_20 = FALSE
	token _23 = NONE
	bool success_24 = FALSE
	rule _25 = NONE
	bool success_26 = FALSE
	UNDEF _27 = NONE
	bool success_28 = FALSE
	auto begin_5 = pos
	while (CURRENT_TOKEN == AUTO_35)
	{
		_2 += CURRENT_TOKEN
		success_3 = TRUE
		begin_5++
		shadow_4.push(_2)
	}
	if (success_3)
	{
		success_1 = TRUE
		pos = begin_5
	}
	_0 = _2
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_36))
	{
		return {}
	}
	_6 = CURRENT_TOKEN
	success_7 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_8 = expr(TOKEN_SEQUENCE)
	if (!(_8.res))
	{
		return {}
	}
	success_9 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_31 = pos
	_14 = cll_block(TOKEN_SEQUENCE)
	if (!(_14.res))
	{
		_16 = cll_spaced_block(TOKEN_SEQUENCE)
		if (!(_16.res))
		{
			return {}
		}
		else 
		{
			success_17 = TRUE
			_12 = _16
		}
	}
	else 
	{
		success_15 = TRUE
		_12 = _14
	}
	_12 += CURRENT_POS_SEQUENCE
	success_13 = TRUE
	begin_31++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_30 = begin_31
	if (!(!STRNCMP(pos, _2)))
	{
		return {}
	}
	_21 += CURRENT_POS_SEQUENCE
	success_20 = TRUE
	begin_30++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_107))
	{
		return {}
	}
	_23 = CURRENT_TOKEN
	success_24 = TRUE
	begin_30++
	skipspaces(TOKEN_SEQUENCE)
	_25 = size(TOKEN_SEQUENCE)
	if (!(_25.res))
	{
		return {}
	}
	success_26 = TRUE
	begin_30++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_29 = begin_30
	if ()
	{
		success_28 = TRUE
		begin_30 = begin_29
	}
	if (success_28)
	{
		success_19 = TRUE
		begin_31 = begin_30
	}
	_18 += shadow_22
	_18 += _23
	_18 += _25
	_18 += _27
	if (success_19)
	{
		success_11 = TRUE
		pos = begin_31
	}
	_10 += _12
	_10 += _18
	data = 
		block: _0 # token
		expr: _6 # token
	;
}
Rule(cll_ternary) {
	rule _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	_0 = expr(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_84))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_4 = expr(TOKEN_SEQUENCE)
	if (!(_4.res))
	{
		return {}
	}
	success_5 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_105))
	{
		return {}
	}
	_6 = CURRENT_TOKEN
	success_7 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_8 = expr(TOKEN_SEQUENCE)
	if (!(_8.res))
	{
		return {}
	}
	success_9 = TRUE
	pos++
	data = 
		second: _8 # rule
		first: _4 # rule
		cond: _0 # rule
	;
}
Rule(expr_logical) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	rule _14 = NONE
	bool success_15 = FALSE
	rule _16 = NONE
	bool success_17 = FALSE
	_2 = expr_compare(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		_4 = expr_arithmetic(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			_6 = expr_for_arithmetic(TOKEN_SEQUENCE)
			if (!(_6.res))
			{
				return {}
			}
			else 
			{
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == LOGICAL_OP))
	{
		return {}
	}
	_8 = CURRENT_TOKEN
	success_9 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_12 = expr_compare(TOKEN_SEQUENCE)
	if (!(_12.res))
	{
		_14 = expr_arithmetic(TOKEN_SEQUENCE)
		if (!(_14.res))
		{
			_16 = expr_for_arithmetic(TOKEN_SEQUENCE)
			if (!(_16.res))
			{
				return {}
			}
			else 
			{
				success_17 = TRUE
				_10 = _16
			}
		}
		else 
		{
			success_15 = TRUE
			_10 = _14
		}
	}
	else 
	{
		success_13 = TRUE
		_10 = _12
	}
	_10 += CURRENT_POS_SEQUENCE
	success_11 = TRUE
	pos++
	data = 
		right: _8 # token
		op: _0 # rule
		left: _0 # rule
	;
}
Rule(expr_compare) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	bool success_12 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = expr_arithmetic(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == COMPARE_OP))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = expr_arithmetic(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
		success_12 = TRUE
	}
	if (!success_12)
	{
		return {}
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = 
		sequence: _7 # rule
		operators: _4 # token
		first: _0 # rule
	;
}
Rule(expr_arithmetic) {
	rule _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	bool success_12 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	_0 = expr_for_arithmetic(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == OP))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = expr_for_arithmetic(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
		success_12 = TRUE
	}
	if (!success_12)
	{
		return {}
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = 
		sequence: _7 # rule
		operators: _4 # token
		first: _0 # rule
	;
}
Rule(expr_for_arithmetic) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	_2 = expr_group(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		_4 = method_call(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			_6 = cll_function_call(TOKEN_SEQUENCE)
			if (!(_6.res))
			{
				_8 = any_data(TOKEN_SEQUENCE)
				if (!(_8.res))
				{
					return {}
				}
				else 
				{
					success_9 = TRUE
					_0 = _8
				}
			}
			else 
			{
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # rule
}
Rule(expr_group) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	if (!(CURRENT_TOKEN == AUTO_40))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_4 = cll_ternary(TOKEN_SEQUENCE)
	if (!(_4.res))
	{
		_6 = expr(TOKEN_SEQUENCE)
		if (!(_6.res))
		{
			return {}
		}
		else 
		{
			success_7 = TRUE
			_2 = _6
		}
	}
	else 
	{
		success_5 = TRUE
		_2 = _4
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_41))
	{
		return {}
	}
	_8 = CURRENT_TOKEN
	success_9 = TRUE
	pos++
	data = _2 # rule
}
Rule(expr_expr_copiable_method_call) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_42))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = copiable_method_call(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_43))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2 # rule
}
Rule(expr) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	rule _14 = NONE
	bool success_15 = FALSE
	_2 = expr_logical(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		_4 = expr_compare(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			_6 = expr_arithmetic(TOKEN_SEQUENCE)
			if (!(_6.res))
			{
				_8 = expr_group(TOKEN_SEQUENCE)
				if (!(_8.res))
				{
					_10 = expr_expr_copiable_method_call(TOKEN_SEQUENCE)
					if (!(_10.res))
					{
						_12 = cll_function_call(TOKEN_SEQUENCE)
						if (!(_12.res))
						{
							_14 = any_data(TOKEN_SEQUENCE)
							if (!(_14.res))
							{
								return {}
							}
							else 
							{
								success_15 = TRUE
								_0 = _14
							}
						}
						else 
						{
							success_13 = TRUE
							_0 = _12
						}
					}
					else 
					{
						success_11 = TRUE
						_0 = _10
					}
				}
				else 
				{
					success_9 = TRUE
					_0 = _8
				}
			}
			else 
			{
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # rule
}
Rule(function_body_call) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_88))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = function_arguments(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_89))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2 # rule
}
Rule(function_body_decl) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_88))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = function_parameters(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_89))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	data = _2 # rule
}
Rule(function_arguments) {
	any _0 = NONE
	bool success_1 = FALSE
	any _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_23 = NONE
	str _9 = NONE
	bool success_10 = FALSE
	str _11 = NONE
	bool success_12 = FALSE
	array shadow_13 = NONE
	any _14 = NONE
	bool success_15 = FALSE
	rule _16 = NONE
	bool success_17 = FALSE
	array shadow_18 = NONE
	token _19 = NONE
	bool success_20 = FALSE
	array shadow_21 = NONE
	auto begin_8 = pos
	do
	{
		_4 = any_data(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			if (!(CURRENT_TOKEN == ID))
			{
				break
			}
			else 
			{
				_6 = CURRENT_TOKEN
				success_7 = TRUE
				_2 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			_2 = _4
		}
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		begin_8++
	}	while(0)

	if (success_3)
	{
		success_1 = TRUE
		pos = begin_8
	}
	skipspaces(TOKEN_SEQUENCE)
	if ((matched(%1
)))
	{
		auto begin_22 = pos
		while (1)
		{
			if (!(*pos == ','))
			{
				break
			}
			_11 += CURRENT_POS_SEQUENCE
			success_12 = TRUE
			begin_22++
			shadow_13.push(_11)
			skipspaces(TOKEN_SEQUENCE)
			_16 = any_data(TOKEN_SEQUENCE)
			if (!(_16.res))
			{
				if (!(CURRENT_TOKEN == ID))
				{
					break
				}
				else 
				{
					_19 = CURRENT_TOKEN
					success_20 = TRUE
					shadow_21.push(_19)
					_14 = _19
				}
			}
			else 
			{
				success_17 = TRUE
				shadow_18.push(_16)
				_14 = _16
			}
			_14 += CURRENT_POS_SEQUENCE
			success_15 = TRUE
			begin_22++
			shadow_23.push(_9)
		}
		if (success_15)
		{
			success_10 = TRUE
			pos = begin_22
		}
		_9 += shadow_13
		_9 += _14
		skipspaces(TOKEN_SEQUENCE)
	}
	data = [%1
,%3
,] # array
}
Rule(function_parameters) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	token _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	if (CURRENT_TOKEN == ID)
	{
		_0 = CURRENT_TOKEN
		success_1 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if ((matched(%1
)))
	{
		auto begin_10 = pos
		while (1)
		{
			if (!(*pos == ','))
			{
				break
			}
			_4 += CURRENT_POS_SEQUENCE
			success_5 = TRUE
			begin_10++
			shadow_6.push(_4)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == ID))
			{
				break
			}
			_7 = CURRENT_TOKEN
			success_8 = TRUE
			begin_10++
			shadow_9.push(_7)
			shadow_11.push(_2)
		}
		if (success_8)
		{
			success_3 = TRUE
			pos = begin_10
		}
		_2 += shadow_6
		_2 += shadow_9
		skipspaces(TOKEN_SEQUENCE)
	}
	data = [%1
,%3
,] # array
}
Rule(cll_function_call) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = function_body_call(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	data = 
		body: _2 # rule
		name: _0 # token
	;
}
Rule(function_decl) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	bool success_7 = FALSE
	rule _9 = NONE
	bool success_10 = FALSE
	rule val = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	rule _14 = NONE
	bool success_15 = FALSE
	rule _16 = NONE
	bool success_17 = FALSE
	if (!(CURRENT_TOKEN == AUTO_48))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_8 = pos
	while (CURRENT_TOKEN == ID)
	{
		_4 += CURRENT_TOKEN
		success_5 = TRUE
		begin_8++
		shadow_6.push(_4)
		success_7 = TRUE
	}
	if (!success_7)
	{
		return {}
	}
	if (success_5)
	{
		success_3 = TRUE
		pos = begin_8
	}
	_2 = _4
	skipspaces(TOKEN_SEQUENCE)
	_9 = function_body_decl(TOKEN_SEQUENCE)
	if (!(_9.res))
	{
		return {}
	}
	success_10 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_18 = pos
	do
	{
		_14 = cll_block(TOKEN_SEQUENCE)
		if (!(_14.res))
		{
			_16 = cll_spaced_block(TOKEN_SEQUENCE)
			if (!(_16.res))
			{
				break
			}
			else 
			{
				success_17 = TRUE
				_12 = _16
			}
		}
		else 
		{
			success_15 = TRUE
			_12 = _14
		}
		_12 += CURRENT_POS_SEQUENCE
		success_13 = TRUE
		begin_18++
	}	while(0)

	if (success_13)
	{
		success_11 = TRUE
		pos = begin_18
	}
	val = _12
	data = 
		value: val # rule
		name: _2 # token
		type: _4 # token
	;
}
Rule(loop_while) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	if (!(CURRENT_TOKEN == AUTO_49))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = expr(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_6 = cll_block(TOKEN_SEQUENCE)
	if (!(_6.res))
	{
		_8 = cll_spaced_block(TOKEN_SEQUENCE)
		if (!(_8.res))
		{
			return {}
		}
		else 
		{
			success_9 = TRUE
			_4 = _8
		}
	}
	else 
	{
		success_7 = TRUE
		_4 = _6
	}
	_4 += CURRENT_POS_SEQUENCE
	success_5 = TRUE
	pos++
	data = 
		block: _4 # rule
		expr: _2 # rule
	;
}
Rule(loop_for) {
	rule _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	token _13 = NONE
	bool success_14 = FALSE
	rule _15 = NONE
	bool success_16 = FALSE
	token _17 = NONE
	bool success_18 = FALSE
	rule _19 = NONE
	bool success_20 = FALSE
	token _21 = NONE
	bool success_22 = FALSE
	rule _23 = NONE
	bool success_24 = FALSE
	rule _25 = NONE
	bool success_26 = FALSE
	rule _27 = NONE
	bool success_28 = FALSE
	_0 = for(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_88))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_12 = pos
	do
	{
		_8 = expr(TOKEN_SEQUENCE)
		if (!(_8.res))
		{
			_10 = cll_var(TOKEN_SEQUENCE)
			if (!(_10.res))
			{
				break
			}
			else 
			{
				success_11 = TRUE
				_6 = _10
			}
		}
		else 
		{
			success_9 = TRUE
			_6 = _8
		}
		_6 += CURRENT_POS_SEQUENCE
		success_7 = TRUE
		begin_12++
	}	while(0)

	if (success_7)
	{
		success_5 = TRUE
		pos = begin_12
	}
	_4 = _6
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_103))
	{
		return {}
	}
	_13 = CURRENT_TOKEN
	success_14 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_15 = expr(TOKEN_SEQUENCE)
	if (_15.res)
	{
		success_16 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_103))
	{
		return {}
	}
	_17 = CURRENT_TOKEN
	success_18 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_19 = expr(TOKEN_SEQUENCE)
	if (_19.res)
	{
		success_20 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_89))
	{
		return {}
	}
	_21 = CURRENT_TOKEN
	success_22 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_25 = cll_block(TOKEN_SEQUENCE)
	if (!(_25.res))
	{
		_27 = cll_spaced_block(TOKEN_SEQUENCE)
		if (!(_27.res))
		{
			return {}
		}
		else 
		{
			success_28 = TRUE
			_23 = _27
		}
	}
	else 
	{
		success_26 = TRUE
		_23 = _25
	}
	_23 += CURRENT_POS_SEQUENCE
	success_24 = TRUE
	pos++
	data = 
		block: _19 # rule
		end: _15 # rule
		cond: _4 # rule
		decl: _6 # rule
	;
}
Rule(method_call) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_11 = NONE
	str _2 = NONE
	bool success_3 = FALSE
	bool success_12 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	array shadow_6 = NONE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_10 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_99))
		{
			break
		}
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		begin_10++
		shadow_6.push(_4)
		skipspaces(TOKEN_SEQUENCE)
		_7 = cll_function_call(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			break
		}
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
		shadow_11.push(_2)
		success_12 = TRUE
	}
	if (!success_12)
	{
		return {}
	}
	if (success_8)
	{
		success_3 = TRUE
		pos = begin_10
	}
	_2 += shadow_6
	_2 += shadow_9
	data = 
		call: _7 # rule
		object: _0 # token
	;
}
Rule(copiable_method_call) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == AUTO_55))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = method_call(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	data = _2 # rule
}
Rule(var_refer) {
	any pre = matched($1
)
	any post = matched($3
)
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _9 = NONE
	bool success_10 = FALSE
	str _11 = NONE
	bool success_12 = FALSE
	token _13 = NONE
	bool success_14 = FALSE
	rule _15 = NONE
	bool success_16 = FALSE
	token _17 = NONE
	bool success_18 = FALSE
	token _20 = NONE
	bool success_21 = FALSE
	token _22 = NONE
	bool success_23 = FALSE
	token _24 = NONE
	bool success_25 = FALSE
	token _26 = NONE
	bool success_27 = FALSE
	auto begin_8 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_60))
		{
			if (!(CURRENT_TOKEN == AUTO_61))
			{
				break
			}
			else 
			{
				_6 = CURRENT_TOKEN
				success_7 = TRUE
				_2 = _6
			}
		}
		else 
		{
			_4 = CURRENT_TOKEN
			success_5 = TRUE
			_2 = _4
		}
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		begin_8++
	}	while(0)

	if (success_3)
	{
		success_1 = TRUE
		pos = begin_8
	}
	_0 = _2
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_9 = CURRENT_TOKEN
	success_10 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_19 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_90))
		{
			break
		}
		_13 = CURRENT_TOKEN
		success_14 = TRUE
		begin_19++
		skipspaces(TOKEN_SEQUENCE)
		_15 = expr(TOKEN_SEQUENCE)
		if (!(_15.res))
		{
			break
		}
		success_16 = TRUE
		begin_19++
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == AUTO_92))
		{
			break
		}
		_17 = CURRENT_TOKEN
		success_18 = TRUE
		begin_19++
	}	while(0)

	if (success_18)
	{
		success_12 = TRUE
		pos = begin_19
	}
	_11 += _13
	_11 += _15
	_11 += _17
	skipspaces(TOKEN_SEQUENCE)
	auto begin_28 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_60))
		{
			if (!(CURRENT_TOKEN == AUTO_61))
			{
				break
			}
			else 
			{
				_26 = CURRENT_TOKEN
				success_27 = TRUE
				_22 = _26
			}
		}
		else 
		{
			_24 = CURRENT_TOKEN
			success_25 = TRUE
			_22 = _24
		}
		_22 += CURRENT_POS_SEQUENCE
		success_23 = TRUE
		begin_28++
	}	while(0)

	if (success_23)
	{
		success_21 = TRUE
		pos = begin_28
	}
	_20 = _22
	data = 
		post: post # any
		pre: pre # any
		brace_expression: _15 # rule
		name: _2 # token
	;
}
Rule(cll_var) {
	rule _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	str _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	_0 = cll_type(TOKEN_SEQUENCE)
	if (_0.res)
	{
		success_1 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_14 = pos
	do
	{
		_6 = assignment_op(TOKEN_SEQUENCE)
		if (!(_6.res))
		{
			break
		}
		success_7 = TRUE
		begin_14++
		skipspaces(TOKEN_SEQUENCE)
		_10 = expr(TOKEN_SEQUENCE)
		if (!(_10.res))
		{
			_12 = cll_ternary(TOKEN_SEQUENCE)
			if (!(_12.res))
			{
				break
			}
			else 
			{
				success_13 = TRUE
				_8 = _12
			}
		}
		else 
		{
			success_11 = TRUE
			_8 = _10
		}
		_8 += CURRENT_POS_SEQUENCE
		success_9 = TRUE
		begin_14++
	}	while(0)

	if (success_9)
	{
		success_5 = TRUE
		pos = begin_14
	}
	_4 += _6
	_4 += _8
	data = 
		value: _8 # rule
		operator: _6 # rule
		id: _2 # token
		type: _0 # rule
	;
}
Token(STRING) {
	data = shadow_17
	str _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	auto begin_20 = pos
	do
	{
		str _4 = NONE
		bool success_5 = FALSE
		if (!(*pos == '\''))
		{
			break
		}
		_4 += CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_20++
		skipspaces(pos)
		array shadow_17 = NONE
		any _6 = NONE
		bool success_7 = FALSE
		auto begin_16 = begin_20
		while (1)
		{
			any _8 = NONE
			bool success_9 = FALSE
			str _10 = NONE
			bool success_11 = FALSE
			array shadow_12 = NONE
			if (!(!STRNCMP(pos, "\\'")))
			{
				str _13 = NONE
				bool success_14 = FALSE
				array shadow_15 = NONE
				if (!(!(*pos == '\'')))
				{
					break
				}
				else 
				{
					_13 += CURRENT_POS_SEQUENCE
					success_14 = TRUE
					shadow_15.push(_13)
					_8 = _13
				}
			}
			else 
			{
				_10 += CURRENT_POS_SEQUENCE
				success_11 = TRUE
				shadow_12.push(_10)
				_8 = _10
			}
			_8 += CURRENT_POS_SEQUENCE
			success_9 = TRUE
			begin_16++
			shadow_17.push(_6)
		}
		if (success_9)
		{
			success_7 = TRUE
			begin_20 = begin_16
		}
		skipspaces(pos)
		str _18 = NONE
		bool success_19 = FALSE
		if (!(*pos == '\''))
		{
			break
		}
		_18 += CURRENT_POS_SEQUENCE
		success_19 = TRUE
		begin_20++
	}	while(0)

	if (success_19)
	{
		success_3 = TRUE
		pos = begin_20
	}
	_2 += _4
	_2 += shadow_17
	_2 += _18
	if (!success_3)
	{
		str _21 = NONE
		bool success_22 = FALSE
		auto begin_39 = pos
		do
		{
			str _23 = NONE
			bool success_24 = FALSE
			if (!(*pos == '"'))
			{
				break
			}
			_23 += CURRENT_POS_SEQUENCE
			success_24 = TRUE
			begin_39++
			skipspaces(pos)
			array shadow_36 = NONE
			any _25 = NONE
			bool success_26 = FALSE
			auto begin_35 = begin_39
			while (1)
			{
				any _27 = NONE
				bool success_28 = FALSE
				str _29 = NONE
				bool success_30 = FALSE
				array shadow_31 = NONE
				if (!(!STRNCMP(pos, "\\"")))
				{
					str _32 = NONE
					bool success_33 = FALSE
					array shadow_34 = NONE
					if (!(!(*pos == '"')))
					{
						break
					}
					else 
					{
						_32 += CURRENT_POS_SEQUENCE
						success_33 = TRUE
						shadow_34.push(_32)
						_27 = _32
					}
				}
				else 
				{
					_29 += CURRENT_POS_SEQUENCE
					success_30 = TRUE
					shadow_31.push(_29)
					_27 = _29
				}
				_27 += CURRENT_POS_SEQUENCE
				success_28 = TRUE
				begin_35++
				shadow_36.push(_25)
			}
			if (success_28)
			{
				success_26 = TRUE
				begin_39 = begin_35
			}
			skipspaces(pos)
			str _37 = NONE
			bool success_38 = FALSE
			if (!(*pos == '"'))
			{
				break
			}
			_37 += CURRENT_POS_SEQUENCE
			success_38 = TRUE
			begin_39++
		}		while(0)

		if (success_38)
		{
			success_22 = TRUE
			pos = begin_39
		}
		_21 += _23
		_21 += shadow_36
		_21 += _37
		if (!success_22)
		{
			return {}
		}
		else 
		{
			_0 = _21
		}
	}
	else 
	{
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(NUMBER) {
	char sign = 
	str main = _6
	num main_n = NUMBER(main)
	char point = _15
	str dec = _15
	num dec_n = NUMBER(dec)
	str full = main+point
	rule _0 = NONE
	bool success_1 = FALSE
	skipspaces(pos)
	str _2 = NONE
	bool success_3 = FALSE
	if (!(*pos == '+' || *pos == '-'))
	{
		return {}
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	pos++
	skipspaces(pos)
	str _4 = NONE
	bool success_5 = FALSE
	str _6 = NONE
	bool success_7 = FALSE
	auto begin_12 = pos
	do
	{
		str _8 = NONE
		bool success_9 = FALSE
		array shadow_10 = NONE
		bool success_11 = FALSE
		while ((*pos>='0' && *pos<='9'))
		{
			_8 += CURRENT_POS_SEQUENCE
			success_9 = TRUE
			begin_12++
			shadow_10.push(_8)
			success_11 = TRUE
		}
		if (!success_11)
		{
			break
		}
	}	while(0)

	if (success_9)
	{
		success_7 = TRUE
		pos = begin_12
	}
	_6 += shadow_10
	if (!success_7)
	{
		str _13 = NONE
		bool success_14 = FALSE
		auto begin_21 = pos
		do
		{
			str _15 = NONE
			bool success_16 = FALSE
			if (!(*pos == '.' || *pos == ','))
			{
				break
			}
			_15 += CURRENT_POS_SEQUENCE
			success_16 = TRUE
			begin_21++
			skipspaces(pos)
			str _17 = NONE
			bool success_18 = FALSE
			array shadow_19 = NONE
			bool success_20 = FALSE
			while ((*pos>='0' && *pos<='9'))
			{
				_17 += CURRENT_POS_SEQUENCE
				success_18 = TRUE
				begin_21++
				shadow_19.push(_17)
				success_20 = TRUE
			}
			if (!success_20)
			{
				break
			}
		}		while(0)

		if (success_18)
		{
			success_14 = TRUE
			pos = begin_21
		}
		_13 += _15
		_13 += shadow_19
		if (!success_14)
		{
			return {}
		}
		else 
		{
			_4 = _13
		}
	}
	else 
	{
		_4 = _6
	}
	_4 += CURRENT_POS_SEQUENCE
	success_5 = TRUE
	pos++
	data = 
		full: full # str
		dec_n: dec_n # num
		dec: dec # str
		main_n: main_n # num
		main: main # str
		sign: sign # char
	;
}
Token(BOOLEAN) {
	str d = NONE
	bool success_0 = FALSE
	auto begin_7 = pos
	str _1 = NONE
	bool success_2 = FALSE
	str _3 = NONE
	bool success_4 = FALSE
	if (!(!STRNCMP(pos, "true")))
	{
		str _5 = NONE
		bool success_6 = FALSE
		if (!(!STRNCMP(pos, "false")))
		{
			return {}
		}
		else 
		{
			_5 += CURRENT_POS_SEQUENCE
			success_6 = TRUE
			_1 = _5
		}
	}
	else 
	{
		_3 += CURRENT_POS_SEQUENCE
		success_4 = TRUE
		_1 = _3
	}
	_1 += CURRENT_POS_SEQUENCE
	success_2 = TRUE
	begin_7++
	if (success_2)
	{
		success_0 = TRUE
		pos = begin_7
	}
	d += _1
	skipspaces(pos)
	bool val = NONE
	data = 
		lit: d # str
		val: val # bool
	;
}
Rule(array) {
	token _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	array shadow_13 = NONE
	str _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	token _15 = NONE
	bool success_16 = FALSE
	if (!(CURRENT_TOKEN == AUTO_90))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_14 = pos
	do
	{
		auto begin_12 = begin_14
		while (1)
		{
			_6 = any_data(TOKEN_SEQUENCE)
			if (!(_6.res))
			{
				break
			}
			success_7 = TRUE
			begin_12++
			shadow_8.push(_6)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == AUTO_78))
			{
				break
			}
			_9 = CURRENT_TOKEN
			success_10 = TRUE
			begin_12++
			shadow_11.push(_9)
			shadow_13.push(_4)
		}
		if (success_10)
		{
			success_5 = TRUE
			begin_14 = begin_12
		}
		_4 += shadow_8
		_4 += shadow_11
	}	while(0)

	if (success_5)
	{
		success_3 = TRUE
		pos = begin_14
	}
	_2 += shadow_13
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_92))
	{
		return {}
	}
	_15 = CURRENT_TOKEN
	success_16 = TRUE
	pos++
	data = _9 # token
}
Rule(object) {
	token _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	array shadow_25 = NONE
	str _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	array shadow_14 = NONE
	token _15 = NONE
	bool success_16 = FALSE
	array shadow_17 = NONE
	token _18 = NONE
	bool success_19 = FALSE
	array shadow_20 = NONE
	rule _21 = NONE
	bool success_22 = FALSE
	array shadow_23 = NONE
	token _26 = NONE
	bool success_27 = FALSE
	token _29 = NONE
	bool success_30 = FALSE
	if (!(CURRENT_TOKEN == AUTO_65))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_28 = pos
	do
	{
		_4 = any_data(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			break
		}
		success_5 = TRUE
		begin_28++
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == AUTO_105))
		{
			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_28++
		skipspaces(TOKEN_SEQUENCE)
		_8 = any_data(TOKEN_SEQUENCE)
		if (!(_8.res))
		{
			break
		}
		success_9 = TRUE
		begin_28++
		skipspaces(TOKEN_SEQUENCE)
		auto begin_24 = begin_28
		while (1)
		{
			if (!(CURRENT_TOKEN == AUTO_78))
			{
				break
			}
			_12 = CURRENT_TOKEN
			success_13 = TRUE
			begin_24++
			shadow_14.push(_12)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == ID))
			{
				break
			}
			_15 = CURRENT_TOKEN
			success_16 = TRUE
			begin_24++
			shadow_17.push(_15)
			skipspaces(TOKEN_SEQUENCE)
			if (!(CURRENT_TOKEN == AUTO_105))
			{
				break
			}
			_18 = CURRENT_TOKEN
			success_19 = TRUE
			begin_24++
			shadow_20.push(_18)
			skipspaces(TOKEN_SEQUENCE)
			_21 = any_data(TOKEN_SEQUENCE)
			if (!(_21.res))
			{
				break
			}
			success_22 = TRUE
			begin_24++
			shadow_23.push(_21)
			shadow_25.push(_10)
		}
		if (success_22)
		{
			success_11 = TRUE
			begin_28 = begin_24
		}
		_10 += shadow_14
		_10 += shadow_17
		_10 += shadow_20
		_10 += shadow_23
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == AUTO_103))
		{
			break
		}
		_26 = CURRENT_TOKEN
		success_27 = TRUE
		begin_28++
	}	while(0)

	if (success_27)
	{
		success_3 = TRUE
		pos = begin_28
	}
	_2 += _4
	_2 += _6
	_2 += _8
	_2 += shadow_25
	_2 += _26
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_70))
	{
		return {}
	}
	_29 = CURRENT_TOKEN
	success_30 = TRUE
	pos++
	data = 
		values: _21 # rule
		keys: _15 # token
		value: _8 # rule
		key: _4 # rule
	;
}
Rule(any_data) {
	any _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	rule _12 = NONE
	bool success_13 = FALSE
	rule _14 = NONE
	bool success_15 = FALSE
	data = _0
	if (!(CURRENT_TOKEN == BOOLEAN))
	{
		if (!(CURRENT_TOKEN == NUMBER))
		{
			if (!(CURRENT_TOKEN == STRING))
			{
				if (!(CURRENT_TOKEN == ID))
				{
					_10 = array(TOKEN_SEQUENCE)
					if (!(_10.res))
					{
						_12 = object(TOKEN_SEQUENCE)
						if (!(_12.res))
						{
							_14 = accessor(TOKEN_SEQUENCE)
							if (!(_14.res))
							{
								return {}
							}
							else 
							{
								success_15 = TRUE
								_0 = _14
							}
						}
						else 
						{
							success_13 = TRUE
							_0 = _12
						}
					}
					else 
					{
						success_11 = TRUE
						_0 = _10
					}
				}
				else 
				{
					_8 = CURRENT_TOKEN
					success_9 = TRUE
					_0 = _8
				}
			}
			else 
			{
				_6 = CURRENT_TOKEN
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			_4 = CURRENT_TOKEN
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		_2 = CURRENT_TOKEN
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(END) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ';' || *pos == '\n'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(NEWLINE) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '\n'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Token(ID) {
	str _0 = NONE
	bool success_1 = FALSE
	auto begin_10 = pos
	str _2 = NONE
	bool success_3 = FALSE
	array shadow_4 = NONE
	while ((*pos>='0' && *pos<='9'))
	{
		_2 += CURRENT_POS_SEQUENCE
		success_3 = TRUE
		begin_10++
		shadow_4.push(_2)
	}
	skipspaces(pos)
	str _5 = NONE
	bool success_6 = FALSE
	if (!((*pos>='a' && *pos<='z') || (*pos>='A' && *pos<='Z') || *pos == '_'))
	{
		return {}
	}
	_5 += CURRENT_POS_SEQUENCE
	success_6 = TRUE
	begin_10++
	skipspaces(pos)
	str _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	while ((*pos>='a' && *pos<='z') || (*pos>='A' && *pos<='Z') || (*pos>='0' && *pos<='9') || *pos == '_')
	{
		_7 += CURRENT_POS_SEQUENCE
		success_8 = TRUE
		begin_10++
		shadow_9.push(_7)
	}
	if (success_8)
	{
		success_1 = TRUE
		pos = begin_10
	}
	_0 += shadow_4
	_0 += _5
	_0 += shadow_9
	data = _0 # str
}
Rule(spacemode) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	if (!(CURRENT_TOKEN == AUTO_71))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_72))
	{
		if (!(CURRENT_TOKEN == AUTO_73))
		{
			if (!(CURRENT_TOKEN == AUTO_74))
			{
				return {}
			}
			else 
			{
				_8 = CURRENT_TOKEN
				success_9 = TRUE
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		_2 = _4
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	pos++
	data = _0 # token
}
Rule(linear_comment) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	if (!(CURRENT_TOKEN == AUTO_75))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_76))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
}
Rule(main) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	_2 = Import(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		_4 = use(TOKEN_SEQUENCE)
		if (!(_4.res))
		{
			_6 = Rule(TOKEN_SEQUENCE)
			if (!(_6.res))
			{
				_8 = spacemode(TOKEN_SEQUENCE)
				if (!(_8.res))
				{
					return {}
				}
				else 
				{
					success_9 = TRUE
					_0 = _8
				}
			}
			else 
			{
				success_7 = TRUE
				_0 = _6
			}
		}
		else 
		{
			success_5 = TRUE
			_0 = _4
		}
	}
	else 
	{
		success_3 = TRUE
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
}
Rule(use_unit) {
	rule _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	_0 = id(TOKEN_SEQUENCE)
	if (!(_0.res))
	{
		return {}
	}
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = any_data(TOKEN_SEQUENCE)
	if (_2.res)
	{
		success_3 = TRUE
		pos++
	}
	data = 
		value: _2 # rule
		name: _0 # rule
	;
}
Rule(use) {
	token _0 = NONE
	bool success_1 = FALSE
	rule _2 = NONE
	bool success_3 = FALSE
	array shadow_13 = NONE
	str _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	rule _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	if (!(CURRENT_TOKEN == AUTO_77))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_2 = use_unit(TOKEN_SEQUENCE)
	if (!(_2.res))
	{
		return {}
	}
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_12 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_78))
		{
			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_12++
		shadow_8.push(_6)
		skipspaces(TOKEN_SEQUENCE)
		_9 = use_unit(TOKEN_SEQUENCE)
		if (!(_9.res))
		{
			break
		}
		success_10 = TRUE
		begin_12++
		shadow_11.push(_9)
		shadow_13.push(_4)
	}
	if (success_10)
	{
		success_5 = TRUE
		pos = begin_12
	}
	_4 += shadow_8
	_4 += shadow_11
	data = 
		second: _9 # rule
		first: _2 # rule
	;
}
Rule(Rule_rule) {
	any _0 = NONE
	bool success_1 = FALSE
	str _2 = NONE
	bool success_3 = FALSE
	any _4 = NONE
	bool success_5 = FALSE
	any _6 = NONE
	bool success_7 = FALSE
	rule _8 = NONE
	bool success_9 = FALSE
	rule _10 = NONE
	bool success_11 = FALSE
	token _12 = NONE
	bool success_13 = FALSE
	rule _14 = NONE
	bool success_15 = FALSE
	rule _16 = NONE
	bool success_17 = FALSE
	rule _18 = NONE
	bool success_19 = FALSE
	rule _20 = NONE
	bool success_21 = FALSE
	rule _23 = NONE
	bool success_24 = FALSE
	rule _26 = NONE
	bool success_27 = FALSE
	rule _28 = NONE
	bool success_29 = FALSE
	rule _30 = NONE
	bool success_31 = FALSE
	rule _32 = NONE
	bool success_33 = FALSE
	rule _34 = NONE
	bool success_35 = FALSE
	auto begin_25 = pos
	do
	{
		auto begin_22 = begin_25
		_8 = Rule_group(TOKEN_SEQUENCE)
		if (!(_8.res))
		{
			_10 = Rule_csequence(TOKEN_SEQUENCE)
			if (!(_10.res))
			{
				if (!(CURRENT_TOKEN == STRING))
				{
					_14 = accessor(TOKEN_SEQUENCE)
					if (!(_14.res))
					{
						_16 = Rule_hex(TOKEN_SEQUENCE)
						if (!(_16.res))
						{
							_18 = Rule_bin(TOKEN_SEQUENCE)
							if (!(_18.res))
							{
								_20 = Rule_other(TOKEN_SEQUENCE)
								if (!(_20.res))
								{
									break
								}
								else 
								{
									success_21 = TRUE
									_6 = _20
								}
							}
							else 
							{
								success_19 = TRUE
								_6 = _18
							}
						}
						else 
						{
							success_17 = TRUE
							_6 = _16
						}
					}
					else 
					{
						success_15 = TRUE
						_6 = _14
					}
				}
				else 
				{
					_12 = CURRENT_TOKEN
					success_13 = TRUE
					_6 = _12
				}
			}
			else 
			{
				success_11 = TRUE
				_6 = _10
			}
		}
		else 
		{
			success_9 = TRUE
			_6 = _8
		}
		_6 += CURRENT_POS_SEQUENCE
		success_7 = TRUE
		begin_22++
		if (success_7)
		{
			success_5 = TRUE
			begin_25 = begin_22
		}
		skipspaces(TOKEN_SEQUENCE)
		_23 = Rule_qualifier(TOKEN_SEQUENCE)
		if (_23.res)
		{
			success_24 = TRUE
			begin_25++
		}
	}	while(0)

	if (success_24)
	{
		success_3 = TRUE
		pos = begin_25
	}
	_2 += _4
	_2 += _23
	if (!success_3)
	{
		_26 = Rule_rule_escaped(TOKEN_SEQUENCE)
		if (!(_26.res))
		{
			_28 = Rule_rule_any(TOKEN_SEQUENCE)
			if (!(_28.res))
			{
				_30 = Rule_rule_op(TOKEN_SEQUENCE)
				if (!(_30.res))
				{
					_32 = cll(TOKEN_SEQUENCE)
					if (!(_32.res))
					{
						_34 = linear_comment(TOKEN_SEQUENCE)
						if (!(_34.res))
						{
							return {}
						}
						else 
						{
							success_35 = TRUE
							_0 = _34
						}
					}
					else 
					{
						success_33 = TRUE
						_0 = _32
					}
				}
				else 
				{
					success_31 = TRUE
					_0 = _30
				}
			}
			else 
			{
				success_29 = TRUE
				_0 = _28
			}
		}
		else 
		{
			success_27 = TRUE
			_0 = _26
		}
	}
	else 
	{
		_0 = _2
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = 
		qualifier: _6 # any
		val: _6 # any
	;
}
Rule(Rule_other) {
	bool m = matched(%1
)
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	array shadow_13 = NONE
	str _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	token _9 = NONE
	bool success_10 = FALSE
	array shadow_11 = NONE
	if (CURRENT_TOKEN == AUTO_80)
	{
		_0 = CURRENT_TOKEN
		success_1 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_12 = pos
	while (1)
	{
		if (!(CURRENT_TOKEN == AUTO_81))
		{
			break
		}
		_6 = CURRENT_TOKEN
		success_7 = TRUE
		begin_12++
		shadow_8.push(_6)
		skipspaces(TOKEN_SEQUENCE)
		if (!(CURRENT_TOKEN == ID))
		{
			break
		}
		_9 = CURRENT_TOKEN
		success_10 = TRUE
		begin_12++
		shadow_11.push(_9)
		shadow_13.push(_4)
	}
	if (success_10)
	{
		success_5 = TRUE
		pos = begin_12
	}
	_4 += shadow_8
	_4 += shadow_11
	data = 
		nested_name: _9 # token
		name: _2 # token
		is_nested: m # bool
	;
}
Rule(Rule_op) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	data = _0
	auto begin_8 = pos
	if (!(CURRENT_TOKEN == AUTO_82))
	{
		if (!(CURRENT_TOKEN == AUTO_83))
		{
			return {}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		_2 = _4
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	begin_8++
	if (success_3)
	{
		success_1 = TRUE
		pos = begin_8
	}
	_0 = _2
}
Rule(Rule_qualifier) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	data = _0
	auto begin_10 = pos
	if (!(CURRENT_TOKEN == AUTO_84))
	{
		if (!(CURRENT_TOKEN == AUTO_85))
		{
			if (!(CURRENT_TOKEN == AUTO_86))
			{
				return {}
			}
			else 
			{
				_8 = CURRENT_TOKEN
				success_9 = TRUE
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		_2 = _4
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	begin_10++
	if (success_3)
	{
		success_1 = TRUE
		pos = begin_10
	}
	_0 = _2
}
Rule(Rule_group) {
	any name = _2
	any r = _0
	str _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	any _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	token _11 = NONE
	bool success_12 = FALSE
	rule _13 = NONE
	bool success_14 = FALSE
	token _15 = NONE
	bool success_16 = FALSE
	auto begin_10 = pos
	do
	{
		if (!(CURRENT_TOKEN == AUTO_87))
		{
			break
		}
		_2 = CURRENT_TOKEN
		success_3 = TRUE
		begin_10++
		skipspaces(TOKEN_SEQUENCE)
		_6 = method_call(TOKEN_SEQUENCE)
		if (!(_6.res))
		{
			if (!(CURRENT_TOKEN == ID))
			{
				break
			}
			else 
			{
				_8 = CURRENT_TOKEN
				success_9 = TRUE
				_4 = _8
			}
		}
		else 
		{
			success_7 = TRUE
			_4 = _6
		}
		_4 += CURRENT_POS_SEQUENCE
		success_5 = TRUE
		begin_10++
	}	while(0)

	if (success_5)
	{
		success_1 = TRUE
		pos = begin_10
	}
	_0 += _2
	_0 += _4
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_88))
	{
		return {}
	}
	_11 = CURRENT_TOKEN
	success_12 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_13 = Rule_rule(TOKEN_SEQUENCE)
	while (_13.res)
	{
		success_14 = TRUE
		pos++
		_13 = Rule_rule(TOKEN_SEQUENCE)
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_89))
	{
		return {}
	}
	_15 = CURRENT_TOKEN
	success_16 = TRUE
	pos++
	data = 
		val: r # any
		variable: name # any
	;
}
Rule(Rule_csequence_symbol) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	data = _0
	auto begin_10 = pos
	if (!(CURRENT_TOKEN == AUTO_93))
	{
		if (!(CURRENT_TOKEN == AUTO_94))
		{
			if (!(CURRENT_TOKEN == AUTO_95))
			{
				return {}
			}
			else 
			{
				_8 = CURRENT_TOKEN
				success_9 = TRUE
				_2 = _8
			}
		}
		else 
		{
			_6 = CURRENT_TOKEN
			success_7 = TRUE
			_2 = _6
		}
	}
	else 
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		_2 = _4
	}
	_2 += CURRENT_POS_SEQUENCE
	success_3 = TRUE
	begin_10++
	if (success_3)
	{
		success_1 = TRUE
		pos = begin_10
	}
	_0 = _2
}
Rule(Rule_csequence_escape) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	data = _2
	if (!(CURRENT_TOKEN == AUTO_96))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	auto begin_6 = pos
	if (!(CURRENT_TOKEN == AUTO_97))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	begin_6++
	if (success_5)
	{
		success_3 = TRUE
		pos = begin_6
	}
	_2 = _4
}
Rule(Rule_csequence_diapason) {
	str _0 = NONE
	bool success_1 = FALSE
	rule from = NONE
	bool success_2 = FALSE
	rule _3 = NONE
	bool success_4 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	rule to = NONE
	bool success_8 = FALSE
	rule _9 = NONE
	bool success_10 = FALSE
	auto begin_12 = pos
	auto begin_5 = begin_12
	_3 = Rule_csequence_symbol(TOKEN_SEQUENCE)
	if (!(_3.res))
	{
		return {}
	}
	success_4 = TRUE
	begin_5++
	if (success_4)
	{
		success_2 = TRUE
		begin_12 = begin_5
	}
	from = _3
	if (!(CURRENT_TOKEN == AUTO_98))
	{
		return {}
	}
	_6 = CURRENT_TOKEN
	success_7 = TRUE
	begin_12++
	auto begin_11 = begin_12
	_9 = Rule_csequence_symbol(TOKEN_SEQUENCE)
	if (!(_9.res))
	{
		return {}
	}
	success_10 = TRUE
	begin_11++
	if (success_10)
	{
		success_8 = TRUE
		begin_12 = begin_11
	}
	to = _9
	if (success_8)
	{
		success_1 = TRUE
		pos = begin_12
	}
	_0 += from
	_0 += _6
	_0 += to
	data = [from,to,] # array
}
Rule(Rule_csequence) {
	bool m = matched(%2
)
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	array shadow_17 = NONE
	rule dt = NONE
	bool success_4 = FALSE
	rule _5 = NONE
	bool success_6 = FALSE
	rule _7 = NONE
	bool success_8 = FALSE
	array shadow_9 = NONE
	rule _10 = NONE
	bool success_11 = FALSE
	array shadow_12 = NONE
	rule _13 = NONE
	bool success_14 = FALSE
	array shadow_15 = NONE
	token _18 = NONE
	bool success_19 = FALSE
	if (!(CURRENT_TOKEN == AUTO_90))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (CURRENT_TOKEN == AUTO_91)
	{
		_2 = CURRENT_TOKEN
		success_3 = TRUE
		pos++
	}
	skipspaces(TOKEN_SEQUENCE)
	auto begin_16 = pos
	while (1)
	{
		_7 = Rule_csequence_escape(TOKEN_SEQUENCE)
		if (!(_7.res))
		{
			_10 = Rule_csequence_symbol(TOKEN_SEQUENCE)
			if (!(_10.res))
			{
				_13 = Rule_csequence_diapason(TOKEN_SEQUENCE)
				if (!(_13.res))
				{
					break
				}
				else 
				{
					success_14 = TRUE
					shadow_15.push(_13)
					_5 = _13
				}
			}
			else 
			{
				success_11 = TRUE
				shadow_12.push(_10)
				_5 = _10
			}
		}
		else 
		{
			success_8 = TRUE
			shadow_9.push(_7)
			_5 = _7
		}
		_5 += CURRENT_POS_SEQUENCE
		success_6 = TRUE
		begin_16++
		shadow_17.push(dt)
	}
	if (success_6)
	{
		success_4 = TRUE
		pos = begin_16
	}
	dt = _5
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_92))
	{
		return {}
	}
	_18 = CURRENT_TOKEN
	success_19 = TRUE
	pos++
	data = 
		val: dt # rule
		not: m # bool
	;
}
Rule(Rule_data_block_inclosed_map) {
	rule data = NONE
	bool success_0 = FALSE
	rule _1 = NONE
	bool success_2 = FALSE
	bool success_3 = FALSE
	auto begin_4 = pos
	_1 = Rule_data_block_key(TOKEN_SEQUENCE)
	while (_1.res)
	{
		success_2 = TRUE
		begin_4++
		_1 = Rule_data_block_key(TOKEN_SEQUENCE)
		success_3 = TRUE
	}
	if (!success_3)
	{
		return {}
	}
	if (success_2)
	{
		success_0 = TRUE
		pos = begin_4
	}
	data = _1
}
Rule(Rule_data_block_key) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_2 = NONE
	bool success_3 = FALSE
	rule name = NONE
	bool success_4 = FALSE
	rule _5 = NONE
	bool success_6 = FALSE
	token _8 = NONE
	bool success_9 = FALSE
	rule dt = NONE
	bool success_10 = FALSE
	rule _11 = NONE
	bool success_12 = FALSE
	rule _13 = NONE
	bool success_14 = FALSE
	rule _15 = NONE
	bool success_16 = FALSE
	while (CURRENT_TOKEN == AUTO_104)
	{
		_0 += CURRENT_TOKEN
		success_1 = TRUE
		pos++
		shadow_2.push(_0)
		success_3 = TRUE
	}
	if (!success_3)
	{
		return {}
	}
	skipspaces(TOKEN_SEQUENCE)
	auto begin_7 = pos
	_5 = id(TOKEN_SEQUENCE)
	if (!(_5.res))
	{
		return {}
	}
	success_6 = TRUE
	begin_7++
	if (success_6)
	{
		success_4 = TRUE
		pos = begin_7
	}
	name = _5
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_105))
	{
		return {}
	}
	_8 = CURRENT_TOKEN
	success_9 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_17 = pos
	_13 = cll_ternary(TOKEN_SEQUENCE)
	if (!(_13.res))
	{
		_15 = expr(TOKEN_SEQUENCE)
		if (!(_15.res))
		{
			return {}
		}
		else 
		{
			success_16 = TRUE
			_11 = _15
		}
	}
	else 
	{
		success_14 = TRUE
		_11 = _13
	}
	_11 += CURRENT_POS_SEQUENCE
	success_12 = TRUE
	begin_17++
	if (success_12)
	{
		success_10 = TRUE
		pos = begin_17
	}
	dt = _11
	data = 
		val: dt # rule
		name: name # rule
	;
}
Rule(Rule_data_block) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	token _6 = NONE
	bool success_7 = FALSE
	rule data = NONE
	bool success_8 = FALSE
	rule _9 = NONE
	bool success_10 = FALSE
	rule _11 = NONE
	bool success_12 = FALSE
	rule _13 = NONE
	bool success_14 = FALSE
	token _16 = NONE
	bool success_17 = FALSE
	while (CURRENT_TOKEN == AUTO_100)
	{
		_0 += CURRENT_TOKEN
		success_1 = TRUE
		pos++
		shadow_2.push(_0)
		success_3 = TRUE
	}
	if (!success_3)
	{
		return {}
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_101))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_102))
	{
		return {}
	}
	_6 = CURRENT_TOKEN
	success_7 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_15 = pos
	_11 = any_data(TOKEN_SEQUENCE)
	if (!(_11.res))
	{
		_13 = Rule_data_block_inclosed_map(TOKEN_SEQUENCE)
		if (!(_13.res))
		{
			return {}
		}
		else 
		{
			success_14 = TRUE
			_9 = _13
		}
	}
	else 
	{
		success_12 = TRUE
		_9 = _11
	}
	_9 += CURRENT_POS_SEQUENCE
	success_10 = TRUE
	begin_15++
	if (success_10)
	{
		success_8 = TRUE
		pos = begin_15
	}
	data = _9
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_103))
	{
		return {}
	}
	_16 = CURRENT_TOKEN
	success_17 = TRUE
	pos++
}
Rule(Rule_escaped) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_106))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	if (!(CURRENT_TOKEN == AUTO_107))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	if (CURRENT_TOKEN == NUMBER)
	{
		_4 = CURRENT_TOKEN
		success_5 = TRUE
		pos++
	}
	data = 
		num: _4 # token
		c: _2 # token
	;
}
Rule(Rule_nested_rule) {
	token _0 = NONE
	bool success_1 = FALSE
	array shadow_2 = NONE
	bool success_3 = FALSE
	token _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	while (CURRENT_TOKEN == AUTO_108)
	{
		_0 += CURRENT_TOKEN
		success_1 = TRUE
		pos++
		shadow_2.push(_0)
		success_3 = TRUE
	}
	if (!success_3)
	{
		return {}
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_109))
	{
		return {}
	}
	_4 = CURRENT_TOKEN
	success_5 = TRUE
	pos++
	_6 = Rule(TOKEN_SEQUENCE)
	if (!(_6.res))
	{
		return {}
	}
	success_7 = TRUE
	pos++
	data = _6 # rule
}
Rule(Rule_hex) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	array shadow_4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_110))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	while (CURRENT_TOKEN == AUTO_111)
	{
		_2 += CURRENT_TOKEN
		success_3 = TRUE
		pos++
		shadow_4.push(_2)
		success_5 = TRUE
	}
	if (!success_5)
	{
		return {}
	}
	data = _2 # token
}
Rule(Rule_bin) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	array shadow_4 = NONE
	bool success_5 = FALSE
	if (!(CURRENT_TOKEN == AUTO_112))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	while (CURRENT_TOKEN == AUTO_113)
	{
		_2 += CURRENT_TOKEN
		success_3 = TRUE
		pos++
		shadow_4.push(_2)
		success_5 = TRUE
	}
	if (!success_5)
	{
		return {}
	}
	data = _2 # token
}
Rule(Rule) {
	token _0 = NONE
	bool success_1 = FALSE
	token _2 = NONE
	bool success_3 = FALSE
	array shadow_10 = NONE
	rule _4 = NONE
	bool success_5 = FALSE
	rule _6 = NONE
	bool success_7 = FALSE
	array shadow_8 = NONE
	rule _11 = NONE
	bool success_12 = FALSE
	rule _13 = NONE
	bool success_14 = FALSE
	token _15 = NONE
	bool success_16 = FALSE
	if (!(CURRENT_TOKEN == ID))
	{
		return {}
	}
	_0 = CURRENT_TOKEN
	success_1 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_105))
	{
		return {}
	}
	_2 = CURRENT_TOKEN
	success_3 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	auto begin_9 = pos
	while (1)
	{
		_6 = Rule_rule(TOKEN_SEQUENCE)
		if (!(_6.res))
		{
			break
		}
		success_7 = TRUE
		begin_9++
		shadow_8.push(_6)
		shadow_10.push(_4)
	}
	if (success_7)
	{
		success_5 = TRUE
		pos = begin_9
	}
	_4 = _6
	skipspaces(TOKEN_SEQUENCE)
	_11 = Rule_data_block(TOKEN_SEQUENCE)
	if (!(_11.res))
	{
		return {}
	}
	success_12 = TRUE
	pos++
	skipspaces(TOKEN_SEQUENCE)
	_13 = Rule_nested_rule(TOKEN_SEQUENCE)
	while (_13.res)
	{
		success_14 = TRUE
		pos++
		_13 = Rule_nested_rule(TOKEN_SEQUENCE)
	}
	skipspaces(TOKEN_SEQUENCE)
	if (!(CURRENT_TOKEN == AUTO_103))
	{
		return {}
	}
	_15 = CURRENT_TOKEN
	success_16 = TRUE
	pos++
	data = 
		nestedRules: _11 # rule
		data_block: _4 # rule
		rule: _6 # rule
		name: _0 # token
	;
}
Token(AUTO_1) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '%'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_3) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '>'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_4) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '$'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_14) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "unsigned")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_15) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "char")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_16) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "short")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_17) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "int")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_18) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "long")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_19) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "long long")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_20) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "float")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_21) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "double")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_22) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "deque")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_23) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "vector")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_24) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "queue")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_25) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "stack")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_26) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "list")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_27) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "forward_list")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_28) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "var")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_29) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "any")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_30) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "num")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_31) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "bool")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_32) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "str")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_33) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "arr")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_34) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "obj")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_35) {
	array shadow_2 = NONE
	str _0 = NONE
	bool success_1 = FALSE
	if (*pos != ' ')
	{
		return {}
		shadow_2.push(_0)
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_36) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "if")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_48) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "fn")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_49) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "while")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_55) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '='))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_60) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "++")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_61) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "--")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_65) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '{'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_70) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '}'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_71) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "spacemode")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_72) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "mixed")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_73) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "skipped")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_74) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "allowed")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_75) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "//")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_76) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!(*pos == '\n')))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_77) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "use")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_78) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ','))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_82) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '|'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_83) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "|&")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_84) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '?'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_85) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '+'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_86) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '*'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_87) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '&'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_88) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '('))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_89) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ')'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_90) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '['))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_91) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '^'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_92) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ']'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_94) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "\\]")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_95) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!(*pos == ']')))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_98) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '-'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_99) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '.'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_101) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "data")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_103) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ';'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_104) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '\n' || *pos == '\r'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_105) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == ':'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_106) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "\\")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_107) {
	str _0 = NONE
	bool success_1 = FALSE
	if (*pos == '\0')
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_108) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '\r' || *pos == '\n'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_109) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '#'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_110) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "0x")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_111) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!((*pos>='1' && *pos<='9') || (*pos>='A' && *pos<='F') || (*pos>='a' && *pos<='f')))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_112) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(!STRNCMP(pos, "0b")))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
Token(AUTO_113) {
	str _0 = NONE
	bool success_1 = FALSE
	if (!(*pos == '0' || *pos == '1'))
	{
		return {}
	}
	_0 += CURRENT_POS_SEQUENCE
	success_1 = TRUE
	pos++
	data = _0 # str
}
