#include <sstream>
#include <algorithm>
#include <queue>
#include <tree.h>
#include <corelib.h>
#include <cpuf/printf.h>
#include <list>
#include <IR/IR.h>
AST& Tree::getRawAst() {
    return ast;
}
void Tree::removeEmptyRule() {
    auto &treeMap = ast.getTreeMap();
    for (auto it = treeMap.begin(); it != treeMap.end();) {
        auto &[name, value] = *it;
        if (value.members.size() == 0) {
            it = treeMap.erase(it);
            continue;
        }
        it++;
    }
}
// void Tree::removeUnusedRule() {
//
// }
void Tree::inlineSingleGroups() {
    for (auto &[name, value] : ast.getTreeMap()) {
        for (auto &member : value.members) {
            if (member.isGroup()) {
                const auto &grp = member.getGroup();
                if (grp.values.size() == 1) {
                    auto replacement = grp.values[0].value; // make a safe copy
                    member.value = replacement; // replace only after you're done accessing
                }
            }
        }
    }
}
void Tree::literalsToToken(
    std::vector<TreeAPI::RuleMember> &literals,
    size_t &count, std::vector<std::pair<std::vector<std::string>, TreeAPI::Rule>> &toInsert,
    std::unordered_map<TreeAPI::RuleMember, TreeAPI::RuleMember> &generated
    ) {
    for (auto &member : literals) {
        if (member.isString() || member.isHex() || member.isBin() || member.isEscaped() || member.isCsequence()) {
            auto find_it = generated.find(member);
            if (find_it != generated.end()) {
                member = find_it->second; // Use the generated member
            } else {
                // create new token
                std::vector<std::string> new_name = {"AUTO_" + std::to_string(count++)};
                auto mem_copy_for_generated = member;
                auto newRuleMember = member;
                member.value = TreeAPI::RuleMemberName {new_name};
                member.isAutoGenerated = true;
                TreeAPI::Rule newRule;

                // make the rule to store the data via @ <rule>
                newRuleMember.prefix.clear();
                newRuleMember.quantifier = '\0';
                newRuleMember.prefix.is_key_value = true;

                // add data block
                newRule.data_block = TreeAPI::DataBlock {TreeAPI::RegularDataBlock {TreeAPI::make_expr_from_value(TreeAPI::CllExprValue {TreeAPI::rvalue {TreeAPI::At()}})}};
                // add copied member
                newRule.members = {newRuleMember};

                // Store the generated member
                generated[mem_copy_for_generated] = member;
                toInsert.push_back(std::make_pair(new_name, newRule));
            }
        } else if (member.isGroup()) {
            auto &group = member.getGroup();
            literalsToToken(group.values, count, toInsert, generated);
        } else if (member.isOp()) {
            auto &op = member.getOp();
            literalsToToken(op.options, count, toInsert, generated);
        }
    }
}
void Tree::literalsToToken() {
    size_t count = 0;
    std::unordered_map<TreeAPI::RuleMember, TreeAPI::RuleMember> generated;
    std::vector<std::pair<std::vector<std::string>, TreeAPI::Rule>> toInsert;
    auto &treeMap = ast.getTreeMap();
    for (auto &[name, value] : treeMap) {
        if (corelib::text::isLower(name.back())) {
            literalsToToken(value.members, count, toInsert, generated);
        }
    }
    for (const auto &[name, newRule] : toInsert) {
        treeMap[name] = newRule;
    }
}
bool Tree::prioritySort(const TreeAPI::String &first, const TreeAPI::String &second) {
    if (first.value.size() != second.value.size())
        return first.value.size() > second.value.size();
    return first.value > second.value;
}
bool Tree::prioritySort(const TreeAPI::RuleMemberBin &first, const TreeAPI::RuleMemberBin &second) {
    return first.bin_chars.size() > second.bin_chars.size();
}

bool Tree::prioritySort(const TreeAPI::RuleMemberHex &first, const TreeAPI::RuleMemberHex &second) {
    return first.hex_chars.size() > second.hex_chars.size();
}

bool Tree::prioritySort(const TreeAPI::RuleMemberName &first, const TreeAPI::RuleMemberName &second) {
    auto &treeMap = ast.getTreeMap();
    const auto first_data = treeMap.find(first.name);
    const auto second_data = treeMap.find(second.name);
    if (first_data == treeMap.end())
        throw Error("Not found Rule_name in map: %$ against %$\n", first.name, second);
    if (second_data == treeMap.end())
        throw Error("Not found Rule_name in map: %$ against %$\n", second.name, first);
    const auto &first_rules = first_data->second.members;
    const auto &second_rules = second_data->second.members;
    for (size_t i = 0; i < first_rules.size() && i < second_rules.size(); ++i) {
        if (first_rules[i] == second_rules[i])
            continue;
        return prioritySort(first_rules[i], second_rules[i]);
    }
    return first_rules.size() > second_rules.size();
}

bool Tree::prioritySort(const TreeAPI::RuleMemberCsequence &first, const TreeAPI::RuleMemberCsequence &second) {
    if (!first.negative && second.negative)
        return true;
    if (first.negative && !second.negative)
        return false;
    return first.characters.size() + first.escaped.size() + first.diapasons.size() >
           second.characters.size() + second.escaped.size() + second.diapasons.size();
}

bool Tree::prioritySort(const TreeAPI::RuleMemberGroup &first, const TreeAPI::RuleMemberGroup &second) {
    for (size_t i = 0; i < first.values.size() && i < second.values.size(); ++i) {
        if (first.values[i] == second.values[i])
            continue;
        return prioritySort(first.values[i], second.values[i]);
    }
    return first.values.size() > second.values.size();
}

bool Tree::prioritySort(const TreeAPI::RuleMemberOp &first, const TreeAPI::RuleMemberOp &second) {
    return prioritySort(first.options.back(), second.options.back());
}
enum class Types {
    string, Rule_escaped, Rule_csequence, Rule_bin, Rule_hex, Rule_any, cll
};
Types getTypes(const TreeAPI::String&) { return Types::string; }
Types getTypes(const TreeAPI::RuleMemberEscaped &) { return Types::Rule_escaped; }
Types getTypes(const TreeAPI::RuleMemberCsequence &) { return Types::Rule_csequence; }
Types getTypes(const TreeAPI::RuleMemberBin&) { return Types::Rule_bin; }
Types getTypes(const TreeAPI::RuleMemberHex&) { return Types::Rule_hex; }
Types getTypes(const TreeAPI::RuleMemberAny&) { return Types::Rule_any; }
Types getTypes(const TreeAPI::Cll&) { return Types::cll; }
// never meet types
Types getTypes(const TreeAPI::RuleMemberName&) { return Types::string; };
Types getTypes(const TreeAPI::RuleMemberGroup &) { return Types::string; }
Types getTypes(const TreeAPI::RuleMemberNospace& ) {return Types::string; }
Types getTypes(const TreeAPI::RuleMemberOp&) { return Types::string; }
Types getTypes(const std::monostate&) { return Types::string; }
bool Tree::prioritySort(const TreeAPI::RuleMember &first, const TreeAPI::RuleMember &second) {
    if (first.isName() && second.isName()) {
        return prioritySort(first.getName(), second.getName());
    }
    if (first.isGroup() && second.isGroup())
        prioritySort(first.getGroup(), second.getGroup());
    if (first.isOp() && second.isOp())
        prioritySort(first.getOp(), second.getOp());
    if (first.isString() && second.isString())
        return prioritySort(first.getString(), second.getString());
    if (first.isEscaped() && second.isEscaped())
        return false;
    if (first.isCsequence() && second.isCsequence())
        return prioritySort(first.getCsequence(), second.getCsequence());
    if (first.isBin() && second.isBin())
        return prioritySort(first.getBin(), second.getBin());
    if (first.isHex() && second.isHex())
        return prioritySort(first.getHex(), second.getHex());
    if (first.isAny() && second.isAny())
        return false;

    if (first.isName()) {
        auto find_it = ast.getTreeMap().find(first.getName().name);
        if (find_it == ast.getTreeMap().end()) {
            throw Error("Not found Rule_name in map: %$ against %$\n", first.getName().name, second);
        }
        return prioritySort(find_it->second.members[0], second);
    }
    if (second.isName()){
        auto find_it = ast.getTreeMap().find(second.getName().name);
        if (find_it == ast.getTreeMap().end()) {
            throw Error("Not found Rule_name in map: %$ against %$\n", second.getName().name, second);
        }
        return prioritySort(first, find_it->second.members[0]);
    }
    if (first.isGroup()) {
        auto &dt = first.getGroup();
        if (dt.values.empty())
            throw Error("Empty group\n");
        return prioritySort(dt.values[0], second);
    }
    if (second.isGroup()) {
        auto &dt = second.getGroup();
        if (dt.values.empty())
            throw Error("Empty group\n");
        return prioritySort(first, dt.values[0]);
    }
    if (first.isOp()) {
        auto &dt = first.getOp();
        if (dt.options.empty())
            throw Error("Empty op\n");
        return prioritySort(dt.options.back(), second);
    }
    if (second.isOp()) {
        auto &dt = second.getOp();
        if (dt.options.empty())
            throw Error("Empty op\n");
        return prioritySort(first, dt.options[0]);
    }
    return std::visit([&](const auto &f, const auto &s) -> bool {
        std::vector<Types> priority_order = {
            Types::string,
            Types::Rule_escaped,
            Types::Rule_csequence,
            Types::Rule_bin,
            Types::Rule_hex,
            Types::Rule_any,
            Types::cll
        };
    
        auto first_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(f));
        auto second_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(s));
        if (first_pos != priority_order.end() && second_pos != priority_order.end()) {
            return first_pos < second_pos;
        } else if (first_pos != priority_order.end()) {
            return true;  // known comes before unknown
        } else if (second_pos != priority_order.end()) {
            return false; // unknown comes after known
        }
        return false; // both unknown
    }, first.value, second.value);
}
void Tree::sortByPriority(std::vector<TreeAPI::RuleMember>& members) {
    for (auto &member : members) {
        if (member.isGroup()) {
            auto &data = member.getGroup();
            sortByPriority(data.values);
        }
        if (member.isOp()) {
            for (auto &option : member.getOp().options) {
                if (option.isGroup()) {
                    auto &data = option.getGroup();
                    sortByPriority(data.values);
                }
            }
            auto& options = member.getOp().options;
            std::sort(options.begin(), options.end(), [this](TreeAPI::RuleMember &first, TreeAPI::RuleMember &second) {return prioritySort(first, second);});
        }
    }

}
void Tree::sortByPriority() {
    for (auto &[name, value] : ast.getTreeMap()) {
        if (value.members.empty()) {
            throw Error("Empty rule\n");
        }
        n = name;
        sortByPriority(value.members);
    }
}
void Tree::addSpaceToken() {
    TreeAPI::Rule spaceTokenRule;
    TreeAPI::RuleMemberCsequence csequence;
    csequence.escaped = {'\t', '\n', '\r', '\v', '\f'};
    csequence.characters = {' '};
    spaceTokenRule.members = { TreeAPI::RuleMember { .quantifier = '+', .value = csequence } };
    ast.getTreeMap()[{"__WHITESPACE"}] = spaceTokenRule;
}
auto Tree::getTerminals() -> std::vector<std::vector<std::string>> {
    std::vector<std::vector<std::string>> set;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isUpper(name.back()))
            set.push_back(name);
    }
    return set;
}
auto Tree::getNonTerminals() -> std::vector<std::vector<std::string>> {
    std::vector<std::vector<std::string>> set;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isLower(name.back()))
            set.push_back(name);
    }
    return set;
}
void Tree::getUsePlacesTable(const std::vector<TreeAPI::RuleMember> &members, const std::vector<std::string> &name) {
    for (const auto &member : members) {
        if (member.isGroup()) {
            getUsePlacesTable(member.getGroup().values, name);
        } else if (member.isOp()) {
            getUsePlacesTable(member.getOp().options, name);
        } else if (member.isName()) {
            use_places[member.getName().name].push_back(name);
        }
    }
}
void Tree::createUsePlacesTable() {
    for (const auto &[name, value] : ast.getTreeMap()) {
        getUsePlacesTable(value.members, name);
    }
}
auto Tree::getUsePlacesTable() -> UsePlaceTable& {
    return use_places;
}
Tree::lexer_code Tree::getCodeForLexer() {
    TreeAPI::RuleMemberOp options;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isLower(name.back()))
            continue;
        auto find_it = use_places.find(name);
        if (find_it != use_places.end()) {
            bool to_add = false;
            for (const auto &use_name : find_it->second) {
                if (corelib::text::isLower(use_name.back())) {
                    to_add = true;
                    break;
                }
            }
            if (to_add) {
                // add this token
                options.options.push_back(TreeAPI::RuleMember { .value = TreeAPI::RuleMemberName { name } });
            }
        } else if (name == std::vector<std::string> { "__WHITESPACE" }) {
            options.options.push_back(TreeAPI::RuleMember { .value = TreeAPI::RuleMemberName { name } });
        } else {
            printf("Not found %s in use_places, use_places size: %zu\n", name.back().c_str(), use_places.size());
        }
        // if not found, do not add this means the token is never used
    }
    sortByPriority(options.options);
    TreeAPI::RuleMember resultRule = { .value = options };
    // get lexer code
    LLIR code(*this, resultRule, true);
    const auto &success_var = code.getSuccessVars();
    code.pop(); // remove space skip
    code.push_begin({LLIR::types::TOKEN});
    code.push({LLIR::types::RULE_END});
    if (success_var.empty())
        throw Error("Empty successvar\n");
    cpuf::printf("success_var[0].name: %s\n", success_var[0].var.name);
    return {code, success_var[0].var};
}