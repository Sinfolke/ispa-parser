#include <sstream>
#include <algorithm>
#include <queue>
#include <tree.h>
#include <corelib.h>
#include <cpuf/printf.h>
#include <list>
#include <IR/IR.h>
AST& Tree::getRawAst() {
    return ast;
}
void Tree::removeEmptyRule() {
    auto &treeMap = ast.getTreeMap();
    for (auto it = treeMap.begin(); it != treeMap.end();) {
        auto &[name, value] = *it;
        if (value.members.size() == 0) {
            it = treeMap.erase(it);
            continue;
        }
        it++;
    }
}
void Tree::inlineSingleGroups() {
    for (auto &[name, value] : ast.getTreeMap()) {
        for (auto &member : value.members) {
            if (member.isGroup()) {
                auto &grp = member.getGroup();
                if (grp.size() == 1) {
                    member.value = grp[0].value;
                }
            }
        }
    }
}
TreeAPI::CllExpr make_expr_from_value(const TreeAPI::CllExprValue& val) {
    TreeAPI::CllExprTerm term;
    term.value = val;

    TreeAPI::CllExprAddition addition;
    addition.value = std::move(term);

    TreeAPI::CllExprCompare compare;
    compare.value = std::move(addition);

    TreeAPI::CllExprLogical logical;
    logical.value = std::move(compare);

    TreeAPI::CllExpr expr;
    expr.value = std::move(logical);

    return expr;
}
void Tree::literalsToToken() {
    size_t count = 0;
    std::vector<std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember>> generated;
    auto &treeMap = ast.getTreeMap();
    for (auto &[name, value] : treeMap) {
        if (corelib::text::isLower(name.back())) {
            for (auto &member : value.members) {
                if (member.isString() || member.isHex() || member.isBin() || member.isEscaped() || member.isCsequence()) {
                    auto find_it = std::find_if(generated.begin(), generated.end(), 
                        [&member](const std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember>& p) {
                            return p.first == member; // Compare RuleMember instances
                        });
                    if (find_it != generated.end()) {
                        member = find_it->second; // Use the generated member
                    } else {
                        // create new Token
                        std::vector<std::string> new_name = {"AUTO_" + std::to_string(count)};
                        member.value = TreeAPI::RuleMemberName {new_name};
                        member.isAutoGenerated = true;
                        TreeAPI::Rule newRule;
    
                        // make the rule to store the data via @ <rule>
                        member.prefix.clear();
                        member.prefix.is_key_value = true;
    
                        // add data block
                        newRule.data_block = TreeAPI::DataBlock {TreeAPI::RegularDataBlock {make_expr_from_value(TreeAPI::CllExprValue {TreeAPI::At()})}};
                        // add copied member
                        newRule.members = {member};
    
                        // Store the generated member
                        generated.push_back({member, member});
    
                        treeMap[new_name] = newRule;
                    }
                }
            }
        }
    }
}
bool Tree::sortPriority(const TreeAPI::String &first, const TreeAPI::String &second) {
    if (first.value.size() != second.value.size())
        return first.value.size() > second.value.size();
    return first.value > second.value;
}

bool Tree::sortPriority(const TreeAPI::RuleMemberBin &first, const TreeAPI::RuleMemberBin &second) {
    return first.bin_chars.size() > second.bin_chars.size();
}

bool Tree::sortPriority(const TreeAPI::RuleMemberHex &first, const TreeAPI::RuleMemberHex &second) {
    return first.hex_chars.size() > second.hex_chars.size();
}

bool Tree::sortPriority(const TreeAPI::RuleMemberName &first, const TreeAPI::RuleMemberName &second) {
    auto &treeMap = ast.getTreeMap();
    auto first_data = treeMap.find(first.name);
    auto second_data = treeMap.find(second.name);
    auto &first_rules = first_data->second.members;
    auto &second_rules = second_data->second.members;
    for (size_t i = 0; i < first_rules.size() && i < second_rules.size(); ++i) {
        if (first_rules[i] == second_rules[i])
            continue;
        return sortPriority(first_rules[i], second_rules[i]);
    }
    return first_rules.size() > second_rules.size();
}

bool Tree::sortPriority(const TreeAPI::RuleMemberCsequence &first, const TreeAPI::RuleMemberCsequence &second) {
    if (!first.negative && second.negative)
        return true;
    if (first.negative && !second.negative)
        return false;
    return first.characters.size() + first.escaped.size() + first.diapasons.size() >
           second.characters.size() + second.escaped.size() + second.diapasons.size();
}

bool Tree::sortPriority(const TreeAPI::RuleMemberGroup &first, const TreeAPI::RuleMemberGroup &second) {
    for (size_t i = 0; i < first.values.size() && i < second.values.size(); ++i) {
        if (first.values[i] == second.values[i])
            continue;
        return sortPriority(first.values[i], second.values[i]);
    }
    return first.values.size() > second.values.size();
}

bool Tree::sortPriority(const TreeAPI::RuleMemberOp &first, const TreeAPI::RuleMemberOp &second) {
    return sortPriority(first.options.back(), second.options.back());
}
enum class Types {
    string, Rule_escaped, Rule_csequence, Rule_bin, Rule_hex, Rule_any, cll
};
Types getTypes(const TreeAPI::String&) { return Types::string; }
Types getTypes(const TreeAPI::RuleMemberEscaped &) { return Types::Rule_escaped; }
Types getTypes(const TreeAPI::RuleMemberCsequence &) { return Types::Rule_csequence; }
Types getTypes(const TreeAPI::RuleMemberBin&) { return Types::Rule_bin; }
Types getTypes(const TreeAPI::RuleMemberHex&) { return Types::Rule_hex; }
Types getTypes(const TreeAPI::RuleMemberAny&) { return Types::Rule_any; }
Types getTypes(const TreeAPI::Cll&) { return Types::cll; }
// never meeted types
Types getTypes(const TreeAPI::RuleMemberName&) { return Types::string; };
Types getTypes(const TreeAPI::RuleMemberGroup &) { return Types::string; }
Types getTypes(const TreeAPI::RuleMemberNospace& ) {return Types::string; }
Types getTypes(const TreeAPI::RuleMemberOp&) { return Types::string; }
Types getTypes(const std::monostate&) { return Types::string; }
bool Tree::sortPriority(const TreeAPI::RuleMember &first, const TreeAPI::RuleMember &second) {
    if (first.isName()) {
        auto &dt = ast.getTreeMap()[first.getName().name];
        return sortPriority(dt.members[0], second);
    }
    if (second.isName()) {
        auto &dt = ast.getTreeMap()[second.getName().name];
        return sortPriority(first, dt.members[0]);
    }
    if (first.isGroup()) {
        auto &dt = first.getGroup();
        return sortPriority(dt[0], second);
    }
    if (second.isGroup()) {
        auto &dt = second.getGroup();
        return sortPriority(first, dt[0]);
    }
    if (first.isOp()) {
        auto &dt = first.getOp();
        return sortPriority(dt.back(), second);
    }
    if (second.isOp()) {
        auto &dt = second.getOp();
        return sortPriority(first, dt[0]);
    }
    return std::visit([&](const auto &f, const auto &s) -> bool {
        std::vector<Types> priority_order = {
            Types::string,
            Types::Rule_escaped,
            Types::Rule_csequence,
            Types::Rule_bin,
            Types::Rule_hex,
            Types::Rule_any,
            Types::cll
        };
    
        auto first_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(f));
        auto second_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(s));
        if (first_pos != priority_order.end() && second_pos != priority_order.end()) {
            return first_pos < second_pos;
        } else if (first_pos != priority_order.end()) {
            return true;  // known comes before unknown
        } else if (second_pos != priority_order.end()) {
            return false; // unknown comes after known
        }
        return false; // both unknown
    }, first.value, second.value);
}
void Tree::sortByPriority(std::vector<TreeAPI::RuleMember>& members) {
    for (auto member : members) {
        if (member.isGroup()) {
            auto &data = member.getGroup();
            sortByPriority(data);
        }
        if (member.isOp()) {
            for (auto &option : member.getOp()) {
                if (option.isGroup()) {
                    auto data = option.getGroup();
                    sortByPriority(data);
                }
            }
            auto& options = member.getOp();
            std::sort(options.begin(), options.end(), [this](TreeAPI::RuleMember &first, TreeAPI::RuleMember &second) {sortPriority(first, second);});
        }
    }

}
void Tree::sortByPriority() {
    for (auto [name, value] : ast.getTreeMap()) {
        sortByPriority(value.members);
    }
}
void Tree::addSpaceToken() {
    TreeAPI::Rule spaceTokenRule;
    TreeAPI::RuleMemberCsequence csequence;
    csequence.escaped = {' ', '\t', '\n', '\r', '\v', '\f'};
    spaceTokenRule.members = { TreeAPI::RuleMember { .quantifier = '+', .value = csequence } };
    ast.getTreeMap()[{"__WHITESPACE"}] = spaceTokenRule;
}
auto Tree::getTerminals() -> std::unordered_set<std::vector<std::string>> {
    std::unordered_set<std::vector<std::string>> set;
    for (auto [name, value] : ast.getTreeMap()) {
        if (corelib::text::isUpper(name.back()))
            set.insert(name);
    }
    return set;
}
auto Tree::getNonTerminals() -> std::unordered_set<std::vector<std::string>> {
    std::unordered_set<std::vector<std::string>> set;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isLower(name.back()))
            set.insert(name);
    }
    return set;
}
void Tree::getUsePlacesTable(const std::vector<TreeAPI::RuleMember> &members, const std::vector<std::string> name, UsePlaceTable &table) {
    size_t index = 0;
    for (const auto &member : members) {
        if (member.isGroup()) {
            getUsePlacesTable(member.getGroup(), name, table);
        } else if (member.isOp()) {
            getUsePlacesTable(member.getOp(), name, table);
        } else if (member.isName()) {
            table[name].push_back(member.getName().name);
        }
    }
}
auto Tree::getUsePlacesTable() -> UsePlaceTable {
    UsePlaceTable result_table;
    for (const auto &[name, value] : ast.getTreeMap()) {
        getUsePlacesTable(value.members, name, result_table);
    }
    return result_table;
}
Tree::lexer_code Tree::getCodeForLexer() {
    TreeAPI::RuleMemberOp options;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isLower(name.back()))
            continue;
        auto find_it = use_places.find(name);
        if (find_it != use_places.end()) {
            bool to_add = false;
            for (const auto &use_name : find_it->second) {
                if (corelib::text::isLower(use_name.back())) {
                    to_add = true;
                    break;
                }
            }
            if (to_add) {
                // add this token
                options.options.push_back(TreeAPI::RuleMember { .value = TreeAPI::RuleMemberName { name } });
            }
        }
        // if not found do not add, this means the token is never used
    }
    TreeAPI::RuleMember resultRule = { .value = options };
    // get lexer code
    LLIR code(*this, resultRule, true);
    code.setIsToken(true);
    const auto &success_var = code.getSuccessVars();
    code.pop(); // remove space skip
    code.push_begin({LLIR::types::TOKEN});
    code.push({LLIR::types::RULE_END});
    return {code, success_var[0].shadow_var.name.empty() ? success_var[0].shadow_var : success_var[0].var};
}