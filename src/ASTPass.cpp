module ASTPass;
import corelib;
import LLIR;
import AST;
import TreeAPI;
import logging;
import std;
void ASTPass::removeEmptyRule(AST &ast) {
    auto &treeMap = ast.getTreeMap();
    for (auto it = treeMap.begin(); it != treeMap.end();) {
        auto &[name, value] = *it;
        if (value.rule_members.size() == 0) {
            it = treeMap.erase(it);
            continue;
        }
        it++;
    }
}
void ASTPass::inlineSingleGroups(AST &ast) {
    for (auto &[name, value] : ast.getTreeMap()) {
        for (auto &member : value.rule_members) {
            if (member.isGroup()) {
                if (member.quantifier != '\0')
                    continue;
                const auto &grp = member.getGroup();
                if (grp.values.size() == 1) {
                    auto replacement = grp.values[0].value; // make a safe copy
                    member.value = replacement; // replace only after you're done accessing
                }
            }
        }
    }
}
void ASTPass::literalsToToken(
    std::vector<TreeAPI::RuleMember> &literals,
    size_t &count,
    std::vector<std::pair<std::vector<std::string>, TreeAPI::Rule>> &toInsert,
    std::vector<std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember>> &generated
    ) {
    for (auto &member : literals) {
        if (member.isString() || member.isHex() || member.isBin() || member.isEscaped() || member.isCsequence()) {
            auto find_it = std::find_if(generated.begin(), generated.end(), [&](const std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember> &pair) {
                return pair.first == member;
            });
            if (find_it != generated.end()) {
                member.value = find_it->second.value; // Use the generated member
            } else {
                // create new token
                std::vector<std::string> new_name = {"AUTO_" + std::to_string(count++)};
                auto mem_copy_for_generated = member;
                auto newRuleMember = member;
                member.value = TreeAPI::RuleMemberName {.name = new_name};
                member.isAutoGenerated = true;
                TreeAPI::Rule newRule;

                // make the rule to store the data via @ <rule>
                newRuleMember.prefix.clear();
                newRuleMember.quantifier = '\0';
                newRuleMember.prefix.is_key_value = true;

                // add data block
                newRule.data_block = TreeAPI::DataBlock {TreeAPI::RegularDataBlock {TreeAPI::make_expr_from_value(TreeAPI::CllExprValue {TreeAPI::rvalue {TreeAPI::At()}})}};
                // add copied member
                newRule.rule_members = {newRuleMember};

                // Store the generated member
                generated.push_back({mem_copy_for_generated, member});
                toInsert.push_back(std::make_pair(new_name, newRule));
            }
        } else if (member.isGroup()) {
            auto &group = member.getGroup();
            literalsToToken(group.values, count, toInsert, generated);
        } else if (member.isOp()) {
            auto &op = member.getOp();
            literalsToToken(op.options, count, toInsert, generated);
        }
    }
}
void ASTPass::literalsToToken(AST &ast) {
    size_t count = 0;
    std::vector<std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember>> generated;
    std::vector<std::pair<std::vector<std::string>, TreeAPI::Rule>> toInsert;
    auto &treeMap = ast.getTreeMap();
    ASTPass pass(ast);
    for (auto &[name, value] : treeMap) {
        if (corelib::text::isLower(name.back())) {
            pass.literalsToToken(value.rule_members, count, toInsert, generated);
        }
    }
    for (const auto &[name, newRule] : toInsert) {
        treeMap[name] = newRule;
    }
}
bool ASTPass::prioritySort(const TreeAPI::String &first, const TreeAPI::String &second) {
    if (first.value.size() != second.value.size())
        return first.value.size() > second.value.size();
    return first.value > second.value;
}
bool ASTPass::prioritySort(const TreeAPI::RuleMemberBin &first, const TreeAPI::RuleMemberBin &second) {
    return first.bin_chars.size() > second.bin_chars.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberHex &first, const TreeAPI::RuleMemberHex &second) {
    return first.hex_chars.size() > second.hex_chars.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberName &first, const TreeAPI::RuleMemberName &second) {
    auto &treeMap = ast->getTreeMap();
    const auto first_data = treeMap.find(first.name);
    const auto second_data = treeMap.find(second.name);
    if (first_data == treeMap.end())
        throw Error("Not found Rule_name in map");
    if (second_data == treeMap.end())
        throw Error("Not found Rule_name in map");
    const auto &first_rules = first_data->second.rule_members;
    const auto &second_rules = second_data->second.rule_members;
    for (size_t i = 0; i < first_rules.size() && i < second_rules.size(); ++i) {
        if (first_rules[i] == second_rules[i]) {
            continue;
        }
        return prioritySort(first_rules[i], second_rules[i]);
    }
    return first_rules.size() > second_rules.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberCsequence &first, const TreeAPI::RuleMemberCsequence &second) {
    if (!first.negative && second.negative)
        return true;
    if (first.negative && !second.negative)
        return false;
    return first.characters.size() + first.escaped.size() + first.diapasons.size() >
           second.characters.size() + second.escaped.size() + second.diapasons.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberGroup &first, const TreeAPI::RuleMemberGroup &second) {
    for (size_t i = 0; i < first.values.size() && i < second.values.size(); ++i) {
        if (first.values[i] == second.values[i])
            continue;
        return prioritySort(first.values[i], second.values[i]);
    }
    return first.values.size() > second.values.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberOp &first, const TreeAPI::RuleMemberOp &second) {
    return prioritySort(first.options.back(), second.options.back());
}
enum class Types {
    string, Rule_escaped, Rule_csequence, Rule_bin, Rule_hex, Rule_any, cll, name, group, nospace, op, empty
};
Types getTypes(const TreeAPI::String&) { return Types::string; }
Types getTypes(const TreeAPI::RuleMemberEscaped &) { return Types::Rule_escaped; }
Types getTypes(const TreeAPI::RuleMemberCsequence &) { return Types::Rule_csequence; }
Types getTypes(const TreeAPI::RuleMemberBin&) { return Types::Rule_bin; }
Types getTypes(const TreeAPI::RuleMemberHex&) { return Types::Rule_hex; }
Types getTypes(const TreeAPI::RuleMemberAny&) { return Types::Rule_any; }
Types getTypes(const TreeAPI::Cll&) { return Types::cll; }
// never meet types
Types getTypes(const TreeAPI::RuleMemberName&) { return Types::name; };
Types getTypes(const TreeAPI::RuleMemberGroup&) { return Types::group; }
Types getTypes(const TreeAPI::RuleMemberNospace&) {return Types::nospace; }
Types getTypes(const TreeAPI::RuleMemberOp&) { return Types::op; }
Types getTypes(const std::monostate&) { return Types::empty; }
bool ASTPass::prioritySort(const TreeAPI::RuleMember &first, const TreeAPI::RuleMember &second) {
    if (first.isName() && second.isName())
        return prioritySort(first.getName(), second.getName());
    if (first.isGroup() && second.isGroup())
        return prioritySort(first.getGroup(), second.getGroup());
    if (first.isOp() && second.isOp())
        return prioritySort(first.getOp(), second.getOp());
    if (first.isString() && second.isString())
        return prioritySort(first.getString(), second.getString());
    if (first.isEscaped() && second.isEscaped())
        return false;
    if (first.isCsequence() && second.isCsequence())
        return prioritySort(first.getCsequence(), second.getCsequence());
    if (first.isBin() && second.isBin())
        return prioritySort(first.getBin(), second.getBin());
    if (first.isHex() && second.isHex())
        return prioritySort(first.getHex(), second.getHex());
    if (first.isAny() && second.isAny())
        return false;

    if (first.isName()) {
        auto find_it = ast->getTreeMap().find(first.getName().name);
        if (find_it == ast->getTreeMap().end()) {
            throw Error("Not found Rule_name in map");
        }
        const auto &members = find_it->second.rule_members;
        return std::visit([&](const auto &f, const auto &s) -> bool {
            if (members.size() > 1 && getTypes(f) == getTypes(s))
                return false;
            return prioritySort(members[0], second);
        }, members[0].value, second.value);
    }
    if (second.isName()){
        auto find_it = ast->getTreeMap().find(second.getName().name);
        if (find_it == ast->getTreeMap().end()) {
            throw Error("Not found Rule_name in map");
        }
        const auto &members = find_it->second.rule_members;
        return std::visit([&](const auto &f, const auto &s) -> bool {
            if (members.size() > 1 && getTypes(f) == getTypes(s))
                return true;
            return prioritySort(first, members[0]);
        }, first.value, members[0].value);
    }
    if (first.isGroup()) {
        auto &dt = first.getGroup();
        if (dt.values.empty())
            throw Error("Empty group");
        return prioritySort(dt.values[0], second);
    }
    if (second.isGroup()) {
        auto &dt = second.getGroup();
        if (dt.values.empty())
            throw Error("Empty group");
        return prioritySort(first, dt.values[0]);
    }
    if (first.isOp()) {
        auto &dt = first.getOp();
        if (dt.options.empty())
            throw Error("Empty op");
        return prioritySort(dt.options.back(), second);
    }
    if (second.isOp()) {
        auto &dt = second.getOp();
        if (dt.options.empty())
            throw Error("Empty op");
        return prioritySort(first, dt.options[0]);
    }
    return std::visit([&](const auto &f, const auto &s) -> bool {
        std::vector<Types> priority_order = {
            Types::string,
            Types::Rule_escaped,
            Types::Rule_csequence,
            Types::Rule_bin,
            Types::Rule_hex,
            Types::Rule_any,
            Types::cll
        };
    
        auto first_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(f));
        auto second_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(s));
        if (first_pos != priority_order.end() && second_pos != priority_order.end()) {
            return first_pos < second_pos;
        } else if (first_pos != priority_order.end()) {
            return true;  // known comes before unknown
        } else if (second_pos != priority_order.end()) {
            return false; // unknown comes after known
        }
        return false; // both unknown
    }, first.value, second.value);
}
void ASTPass::sortByPriority(AST &ast, TreeAPI::RuleMemberOp& options) {
    ASTPass pass(ast);
    std::sort(options.options.begin(), options.options.end(), [&](TreeAPI::RuleMember &first, TreeAPI::RuleMember &second) {
        return pass.prioritySort(first, second);
    });
}
void ASTPass::sortByPriority(AST &ast, std::vector<TreeAPI::RuleMember>& members) {
    for (auto &member : members) {
        if (member.isGroup()) {
            sortByPriority(ast, member.getGroup().values);
        }
        if (member.isOp()) {
            for (auto &option : member.getOp().options) {
                if (option.isGroup()) {
                    sortByPriority(ast, option.getGroup().values);
                }
            }
            sortByPriority(ast, member.getOp());
        }
    }
}
void ASTPass::sortByPriority(AST &ast) {
    for (auto &[name, value] : ast.getTreeMap()) {
        if (value.rule_members.empty()) {
            throw Error("Empty rule");
        }
        ASTPass pass(ast);
        pass.sortByPriority(ast, value.rule_members);
    }
}
void ASTPass::addSpaceToken(AST &ast) {
    TreeAPI::Rule spaceTokenRule;
    TreeAPI::RuleMemberCsequence csequence;
    csequence.escaped = {'t', 'n', 'r', 'v', 'f'};
    csequence.characters = {' '};
    spaceTokenRule.rule_members = { TreeAPI::RuleMember { .quantifier = '+', .value = csequence } };
    ast.getTreeMap()[{"__WHITESPACE"}] = spaceTokenRule;
}
void ASTPass::removeEmptyRule() {
    removeEmptyRule(*ast);
}
void ASTPass::inlineSingleGroups() {
    inlineSingleGroups(*ast);
}
void ASTPass::literalsToToken() {
    literalsToToken(*ast);
}
void ASTPass::sortByPriority() {
    sortByPriority(*ast);
}
void ASTPass::addSpaceToken() {
    addSpaceToken(*ast);
}