module;
#include <sstream>
#include <algorithm>
#include <cpuf/printf.h>
module ASTPass;
import corelib;
import LLIR;
import AST;
import TreeAPI;
AST& ASTPass::getRawAst() {
    return ast;
}
auto ASTPass::getFirstSet() -> First & {
    return first;
}
auto ASTPass::getFollowSet() -> Follow & {
    return follow;
}
void ASTPass::removeEmptyRule() {
    auto &treeMap = ast.getTreeMap();
    for (auto it = treeMap.begin(); it != treeMap.end();) {
        auto &[name, value] = *it;
        if (value.members.size() == 0) {
            it = treeMap.erase(it);
            continue;
        }
        it++;
    }
}
// void Tree::removeUnusedRule() {
//
// }
void ASTPass::inlineSingleGroups() {
    for (auto &[name, value] : ast.getTreeMap()) {
        for (auto &member : value.members) {
            if (member.isGroup()) {
                if (member.quantifier != '\0')
                    continue;
                const auto &grp = member.getGroup();
                if (grp.values.size() == 1) {
                    auto replacement = grp.values[0].value; // make a safe copy
                    member.value = replacement; // replace only after you're done accessing
                }
            }
        }
    }
}
void ASTPass::literalsToToken(
    std::vector<TreeAPI::RuleMember> &literals,
    size_t &count,
    std::vector<std::pair<std::vector<std::string>, TreeAPI::Rule>> &toInsert,
    std::vector<std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember>> &generated
    ) {
    for (auto &member : literals) {
        if (member.isString() || member.isHex() || member.isBin() || member.isEscaped() || member.isCsequence()) {
            auto find_it = std::find_if(generated.begin(), generated.end(), [&](const std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember> &pair) {
                return pair.first == member;
            });
            if (find_it != generated.end()) {
                member.value = find_it->second.value; // Use the generated member
            } else {
                // create new token
                std::vector<std::string> new_name = {"AUTO_" + std::to_string(count++)};
                auto mem_copy_for_generated = member;
                auto newRuleMember = member;
                member.value = TreeAPI::RuleMemberName {new_name};
                member.isAutoGenerated = true;
                TreeAPI::Rule newRule;

                // make the rule to store the data via @ <rule>
                newRuleMember.prefix.clear();
                newRuleMember.quantifier = '\0';
                newRuleMember.prefix.is_key_value = true;

                // add data block
                newRule.data_block = TreeAPI::DataBlock {TreeAPI::RegularDataBlock {TreeAPI::make_expr_from_value(TreeAPI::CllExprValue {TreeAPI::rvalue {TreeAPI::At()}})}};
                // add copied member
                newRule.members = {newRuleMember};

                // Store the generated member
                generated.push_back({mem_copy_for_generated, member});
                toInsert.push_back(std::make_pair(new_name, newRule));
            }
        } else if (member.isGroup()) {
            auto &group = member.getGroup();
            literalsToToken(group.values, count, toInsert, generated);
        } else if (member.isOp()) {
            auto &op = member.getOp();
            literalsToToken(op.options, count, toInsert, generated);
        }
    }
}
void ASTPass::literalsToToken() {
    size_t count = 0;
    std::vector<std::pair<TreeAPI::RuleMember, TreeAPI::RuleMember>> generated;
    std::vector<std::pair<std::vector<std::string>, TreeAPI::Rule>> toInsert;
    auto &treeMap = ast.getTreeMap();
    for (auto &[name, value] : treeMap) {
        if (corelib::text::isLower(name.back())) {
            literalsToToken(value.members, count, toInsert, generated);
        }
    }
    for (const auto &[name, newRule] : toInsert) {
        treeMap[name] = newRule;
    }
}
bool ASTPass::prioritySort(const TreeAPI::String &first, const TreeAPI::String &second) {
    if (first.value.size() != second.value.size())
        return first.value.size() > second.value.size();
    return first.value > second.value;
}
bool ASTPass::prioritySort(const TreeAPI::RuleMemberBin &first, const TreeAPI::RuleMemberBin &second) {
    return first.bin_chars.size() > second.bin_chars.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberHex &first, const TreeAPI::RuleMemberHex &second) {
    return first.hex_chars.size() > second.hex_chars.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberName &first, const TreeAPI::RuleMemberName &second) {
    auto &treeMap = ast.getTreeMap();
    const auto first_data = treeMap.find(first.name);
    const auto second_data = treeMap.find(second.name);
    if (first_data == treeMap.end())
        throw Error("Not found Rule_name in map: %$ against %$\n", first.name, second);
    if (second_data == treeMap.end())
        throw Error("Not found Rule_name in map: %$ against %$\n", second.name, first);
    const auto &first_rules = first_data->second.members;
    const auto &second_rules = second_data->second.members;
    for (size_t i = 0; i < first_rules.size() && i < second_rules.size(); ++i) {
        if (first_rules[i] == second_rules[i]) {
            continue;
        }
        return prioritySort(first_rules[i], second_rules[i]);
    }
    return first_rules.size() > second_rules.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberCsequence &first, const TreeAPI::RuleMemberCsequence &second) {
    if (!first.negative && second.negative)
        return true;
    if (first.negative && !second.negative)
        return false;
    return first.characters.size() + first.escaped.size() + first.diapasons.size() >
           second.characters.size() + second.escaped.size() + second.diapasons.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberGroup &first, const TreeAPI::RuleMemberGroup &second) {
    for (size_t i = 0; i < first.values.size() && i < second.values.size(); ++i) {
        if (first.values[i] == second.values[i])
            continue;
        return prioritySort(first.values[i], second.values[i]);
    }
    return first.values.size() > second.values.size();
}

bool ASTPass::prioritySort(const TreeAPI::RuleMemberOp &first, const TreeAPI::RuleMemberOp &second) {
    return prioritySort(first.options.back(), second.options.back());
}
enum class Types {
    string, Rule_escaped, Rule_csequence, Rule_bin, Rule_hex, Rule_any, cll, name, group, nospace, op, empty
};
Types getTypes(const TreeAPI::String&) { return Types::string; }
Types getTypes(const TreeAPI::RuleMemberEscaped &) { return Types::Rule_escaped; }
Types getTypes(const TreeAPI::RuleMemberCsequence &) { return Types::Rule_csequence; }
Types getTypes(const TreeAPI::RuleMemberBin&) { return Types::Rule_bin; }
Types getTypes(const TreeAPI::RuleMemberHex&) { return Types::Rule_hex; }
Types getTypes(const TreeAPI::RuleMemberAny&) { return Types::Rule_any; }
Types getTypes(const TreeAPI::Cll&) { return Types::cll; }
// never meet types
Types getTypes(const TreeAPI::RuleMemberName&) { return Types::name; };
Types getTypes(const TreeAPI::RuleMemberGroup&) { return Types::group; }
Types getTypes(const TreeAPI::RuleMemberNospace&) {return Types::nospace; }
Types getTypes(const TreeAPI::RuleMemberOp&) { return Types::op; }
Types getTypes(const std::monostate&) { return Types::empty; }
bool ASTPass::prioritySort(const TreeAPI::RuleMember &first, const TreeAPI::RuleMember &second) {
    if (first.isName() && second.isName())
        return prioritySort(first.getName(), second.getName());
    if (first.isGroup() && second.isGroup())
        return prioritySort(first.getGroup(), second.getGroup());
    if (first.isOp() && second.isOp())
        return prioritySort(first.getOp(), second.getOp());
    if (first.isString() && second.isString())
        return prioritySort(first.getString(), second.getString());
    if (first.isEscaped() && second.isEscaped())
        return false;
    if (first.isCsequence() && second.isCsequence())
        return prioritySort(first.getCsequence(), second.getCsequence());
    if (first.isBin() && second.isBin())
        return prioritySort(first.getBin(), second.getBin());
    if (first.isHex() && second.isHex())
        return prioritySort(first.getHex(), second.getHex());
    if (first.isAny() && second.isAny())
        return false;

    if (first.isName()) {
        auto find_it = ast.getTreeMap().find(first.getName().name);
        if (find_it == ast.getTreeMap().end()) {
            throw Error("Not found Rule_name in map: %$ against %$\n", first.getName().name, second);
        }
        const auto &members = find_it->second.members;
        return std::visit([&](const auto &f, const auto &s) -> bool {
            if (members.size() > 1 && getTypes(f) == getTypes(s))
                return false;
            return prioritySort(members[0], second);
        }, members[0].value, second.value);
    }
    if (second.isName()){
        auto find_it = ast.getTreeMap().find(second.getName().name);
        if (find_it == ast.getTreeMap().end()) {
            throw Error("Not found Rule_name in map: %$ against %$\n", second.getName().name, second);
        }
        const auto &members = find_it->second.members;
        return std::visit([&](const auto &f, const auto &s) -> bool {
            if (members.size() > 1 && getTypes(f) == getTypes(s))
                return true;
            return prioritySort(first, members[0]);
        }, first.value, members[0].value);
    }
    if (first.isGroup()) {
        auto &dt = first.getGroup();
        if (dt.values.empty())
            throw Error("Empty group\n");
        return prioritySort(dt.values[0], second);
    }
    if (second.isGroup()) {
        auto &dt = second.getGroup();
        if (dt.values.empty())
            throw Error("Empty group\n");
        return prioritySort(first, dt.values[0]);
    }
    if (first.isOp()) {
        auto &dt = first.getOp();
        if (dt.options.empty())
            throw Error("Empty op\n");
        return prioritySort(dt.options.back(), second);
    }
    if (second.isOp()) {
        auto &dt = second.getOp();
        if (dt.options.empty())
            throw Error("Empty op\n");
        return prioritySort(first, dt.options[0]);
    }
    return std::visit([&](const auto &f, const auto &s) -> bool {
        std::vector<Types> priority_order = {
            Types::string,
            Types::Rule_escaped,
            Types::Rule_csequence,
            Types::Rule_bin,
            Types::Rule_hex,
            Types::Rule_any,
            Types::cll
        };
    
        auto first_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(f));
        auto second_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(s));
        if (first_pos != priority_order.end() && second_pos != priority_order.end()) {
            return first_pos < second_pos;
        } else if (first_pos != priority_order.end()) {
            return true;  // known comes before unknown
        } else if (second_pos != priority_order.end()) {
            return false; // unknown comes after known
        }
        return false; // both unknown
    }, first.value, second.value);
}
void ASTPass::sortByPriority(TreeAPI::RuleMemberOp& options) {
    std::sort(options.options.begin(), options.options.end(), [this](TreeAPI::RuleMember &first, TreeAPI::RuleMember &second) {return prioritySort(first, second);});
}
void ASTPass::sortByPriority(std::vector<TreeAPI::RuleMember>& members) {
    for (auto &member : members) {
        if (member.isGroup()) {
            sortByPriority(member.getGroup().values);
        }
        if (member.isOp()) {
            for (auto &option : member.getOp().options) {
                if (option.isGroup()) {
                    sortByPriority(option.getGroup().values);
                }
            }
            sortByPriority(member.getOp());
        }
    }
}
void ASTPass::sortByPriority() {
    for (auto &[name, value] : ast.getTreeMap()) {
        if (value.members.empty()) {
            throw Error("Empty rule\n");
        }
        sortByPriority(value.members);
    }
}
void ASTPass::addSpaceToken() {
    TreeAPI::Rule spaceTokenRule;
    TreeAPI::RuleMemberCsequence csequence;
    csequence.escaped = {'t', 'n', 'r', 'v', 'f'};
    csequence.characters = {' '};
    spaceTokenRule.members = { TreeAPI::RuleMember { .quantifier = '+', .value = csequence } };
    ast.getTreeMap()[{"__WHITESPACE"}] = spaceTokenRule;
}
auto ASTPass::getTerminals() -> std::vector<std::vector<std::string>> {
    std::vector<std::vector<std::string>> set;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isUpper(name.back()))
            set.push_back(name);
    }
    return set;
}
auto ASTPass::getNonTerminals() -> std::vector<std::vector<std::string>> {
    std::vector<std::vector<std::string>> set;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isLower(name.back()))
            set.push_back(name);
    }
    return set;
}
void ASTPass::getUsePlacesTable(const std::vector<TreeAPI::RuleMember> &members, const std::vector<std::string> &name) {
    for (const auto &member : members) {
        if (member.isGroup()) {
            getUsePlacesTable(member.getGroup().values, name);
        } else if (member.isOp()) {
            getUsePlacesTable(member.getOp().options, name);
        } else if (member.isName()) {
            use_places[member.getName().name].push_back(name);
        }
    }
}
void ASTPass::createUsePlacesTable() {
    for (const auto &[name, value] : ast.getTreeMap()) {
        getUsePlacesTable(value.members, name);
    }
}
auto ASTPass::getUsePlacesTable() -> UsePlaceTable& {
    return use_places;
}
void ASTPass::constructNullableSet() {
    bool changed;
    do {
        changed = false;
        for (const auto &[name, value] : ast.getTreeMap()) {
            if (corelib::text::isUpper(name.back())) continue;
            if (nullable[name]) continue;

            bool all_nullable = true;
            for (const auto &member : value.members) {
                if (member.isName()) {
                    const auto &n = member.getName().name;
                    if (corelib::text::isUpper(n.back()) || !nullable[n]) {
                        all_nullable = false;
                        break;
                    }
                } else if (member.isGroup() || member.isOp()) {
                    all_nullable = false;
                    break;
                } else if (member.quantifier != '?' && member.quantifier != '*') {
                    all_nullable = false;
                    break;
                }
            }

            if (all_nullable) {
                nullable[name] = true;
                changed = true;
            }
        }
    } while (changed);
}
auto ASTPass::constructFirstSet(const std::vector<TreeAPI::RuleMember>& members, const std::vector<std::string> &nonterminal) -> std::set<std::vector<std::string>> {
    bool nullable_prefix = true;
    std::set<std::vector<std::string>> set;
    for (const auto &member : members) {
        if (member.isGroup()) {
            auto group_set = constructFirstSet(member.getGroup().values, nonterminal);
            set.insert(group_set.begin(), group_set.end());
            if (member.quantifier == '\0' || member.quantifier == '+') {
                nullable_prefix = false;
                break;
            }
            continue;
        }
        if (member.isOp()) {
            for (const auto &el : member.getOp().options) {
                std::vector<TreeAPI::RuleMember> mem = {el};
                auto op_set = constructFirstSet(mem, nonterminal);
                set.insert(op_set.begin(), op_set.end());
            }
            break; // rule_op is never with quantifier
        }
        if (member.isNospace())
            continue;
        const auto &rule = member.getName();
        if (rule.name == nonterminal) {
            continue;
        }
        if (corelib::text::isLower(rule.name.back())) {
            auto find = first.find(rule.name);
            const auto &otherFirst = first[rule.name];
            set.insert(otherFirst.begin(), otherFirst.end());
            if (!nullable[rule.name]) {
                nullable_prefix = false;
                break;
            }
        } else {
            set.insert(rule.name);
            if (member.quantifier == '\0' || member.quantifier == '+') {
                nullable_prefix = false;
                break;
            }
        }
    }
    // If all symbols in this production were nullable
    if (nullable_prefix) {
        set.insert({"ε"});
    }
    return set;
}
void ASTPass::constructFirstSet() {
    bool changed;
    do {
        changed = false;
        for (const auto &[name, value] : ast.getTreeMap()) {
            // cpuf::printf("constructing first set for %$ -> ", nonterminal);
            if (corelib::text::isUpper(name.back())) {
                continue;
            }
            std::set<std::vector<std::string>> visited;
            auto set = constructFirstSet(value.members, name);
            auto size = first[name].size();
            first[name].insert(set.begin(), set.end());
            if (first[name].size() != size)
                changed = true;
        }
    } while (changed);
}

void ASTPass::constructFollowSet() {
    bool hasChanges;
    bool prevDependedChanged;
    std::vector<std::vector<std::string>> prev_depend;
    std::vector<std::vector<std::string>> changed;
    do {
        hasChanges = false;
        prevDependedChanged = false;
        prev_depend.clear();
        changed.clear();
        for (const auto &[name, value] : ast.getTreeMap()) {
            if (corelib::text::isUpper(name.back())) {
                continue;
            }
            bool is_left_recursive = false;
            if (value.members.size() > 0 && value.members[0].isName() && name == value.members[0].getName().name) {
                is_left_recursive = true;
            }
            for (auto it = value.members.begin(); it != value.members.end(); it++) {
                if (!it->isName()) {
                    continue;
                }
                auto current = it->getName();

                if (name == current.name) {
                    // include first(name)
                    auto f = first[name];
                    for (auto &e : f) {
                        if (e == std::vector<std::string>{"ε"}) {
                            continue;
                        }
                        if (follow[name].insert(e).second)
                            hasChanges = true;
                    }
                    prev_depend.push_back(name);
                } else if (is_left_recursive && corelib::text::isLower(current.name.back())) {
                    auto prev_size = follow[current.name].size();
                    follow[current.name].insert(follow[name].begin(), follow[name].end());
                    if (prev_size != follow[current.name].size())
                        hasChanges = true;
                    prev_depend.push_back(current.name);
                }
                if (it + 1 == value.members.end()) {
                    // Add FOLLOW of LHS (the left-hand-side nonterminal)
                    auto &f_lhs = follow[name];
                    for (auto &sym : f_lhs) {
                        if (follow[current.name].insert(sym).second)
                            hasChanges = true;
                    }
                } else {
                    auto next = (it + 1);
                    while (!next->isName() && next != value.members.end()) {
                        next++;
                    }
                    if (next == value.members.end()) {
                        // Add FOLLOW of LHS (the left-hand-side nonterminal)
                        auto &f_lhs = follow[name];
                        for (auto &sym : f_lhs) {
                            if (follow[current.name].insert(sym).second)
                                hasChanges = true;
                        }
                    } else {
                        const auto &next_name = next->getName();
                        if (corelib::text::isUpper(next_name.name.back())) {
                            // terminal, just push
                            if (follow[current.name].insert(next_name.name).second)
                                hasChanges = true;
                        } else {
                            // non-terminal, insert it's first
                            auto f = first[next_name.name];
                            bool has_epsilon = false;
                            for (auto &e : f) {
                                if (e == std::vector<std::string>{"ε"}) {
                                    has_epsilon = true;
                                    continue;
                                }
                                if (follow[current.name].insert(e).second)
                                    hasChanges = true;
                            }
                            if (has_epsilon) {
                                // if ε in FIRST(next), add FOLLOW of LHS
                                auto &f_lhs = follow[name];
                                for (auto &sym : f_lhs) {
                                    if (follow[current.name].insert(sym).second)
                                        hasChanges = true;
                                }
                            }
                            prev_depend.push_back(next_name.name);
                        }
                    }

                }
            }
            if (hasChanges) {
                changed.push_back(name);
            }
        }
        if (!hasChanges) {
            // slight optimization: perform check only if this could be last iteration
            for (auto change_symbol : changed) {
                if (std::find(prev_depend.begin(), prev_depend.end(), change_symbol) != prev_depend.end()) {
                    prevDependedChanged = true;
                    break;
                }
            }
        }
    } while(hasChanges || prevDependedChanged);
}
ASTPass::lexer_code ASTPass::getCodeForLexer() {
    TreeAPI::RuleMemberOp options;
    for (const auto &[name, value] : ast.getTreeMap()) {
        if (corelib::text::isLower(name.back()))
            continue;
        auto find_it = use_places.find(name);
        if (find_it != use_places.end() && name != std::vector<std::string>{"__WHITESPACE"}) {
            bool to_add = false;
            for (const auto &use_name : find_it->second) {
                if (corelib::text::isLower(use_name.back())) {
                    to_add = true;
                    break;
                }
            }
            if (to_add) {
                // add this token
                options.options.push_back(TreeAPI::RuleMember { .value = TreeAPI::RuleMemberName { name } });
            }
        } else if (name == std::vector<std::string> { "__WHITESPACE" }) {
            options.options.push_back(TreeAPI::RuleMember { .value = TreeAPI::RuleMemberName { name } });
        } else {
            printf("Not found %s in use_places\n", name.back().c_str());
        }
        // if not found, do not add this means the token is never used
    }
    sortByPriority(options);
    TreeAPI::RuleMember resultRule = { .value = options };
    // get lexer code
    LLIR_old code(*this, resultRule, true);
    const auto &success_var = code.getSuccessVars();
    code.pop(); // remove space skip
    code.push_begin({LLIR_old::types::TOKEN});
    code.push({LLIR_old::types::RULE_END});
    if (success_var.empty())
        throw Error("Empty success var\n");
    return {code, success_var[0].var};
}