module ASTPass;
import corelib;
import LLIR;
import AST.Tree;
import AST.API;
import cpuf.printf;
import logging;
import std;
void AST::TreePass::removeEmptyRule(AST::Tree &ast) {
    auto &treeMap = ast.getTreeMap();
    for (auto it = treeMap.begin(); it != treeMap.end();) {
        auto &[name, value] = *it;
        if (value.rule_members.empty()) {
            it = treeMap.erase(it);
            continue;
        }
        it++;
    }
}
auto AST::TreePass::inlineGroup(AST::RuleMemberGroup group, stdu::vector<AST::RuleMember> &members, stdu::vector<AST::RuleMember>::iterator toInsert)
    -> stdu::vector<AST::RuleMember>::iterator // group must be copy else on element insertion iterators will invalidate
{
    // recursively inline nested groups
    for (size_t i = 0; i < group.values.size(); ++i) {
        auto &el = group.values[i];
        if (el.isGroup() && el.quantifier == '\0') {
            // Careful: this may still reallocate and change size
            inlineGroup(el.getGroup(), group.values, group.values.begin() + i);
            i += el.getGroup().values.size();
        }
    }
    // inline this group
    return members.insert(toInsert, group.values.begin(), group.values.end()) + static_cast<stdu::vector<AST::RuleMember>::difference_type>(group.values.size());
}
void AST::TreePass::inlineSingleGroups(AST::Tree &ast) {
    for (auto &[name, value] : ast.getTreeMap()) {
        for (auto it = value.rule_members.begin(); it != value.rule_members.end(); ++it) {
            auto &member = *it;
            if (member.isGroup()) {
                if (member.quantifier != '\0')
                    continue;
                it = inlineGroup(member.getGroup(), value.rule_members, it);
            }
        }
    }
}
void AST::TreePass::literalsToToken(
    stdu::vector<AST::RuleMember> &literals,
    size_t &count,
    stdu::vector<std::pair<stdu::vector<std::string>, AST::Rule>> &toInsert,
    stdu::vector<std::pair<AST::RuleMember, AST::RuleMember>> &generated
    ) {
    for (auto &member : literals) {
        if (member.isString() || member.isHex() || member.isBin() || member.isEscaped() || member.isCsequence()) {
            auto find_it = std::find_if(generated.begin(), generated.end(), [&](const std::pair<AST::RuleMember, AST::RuleMember> &pair) {
                return pair.first == member;
            });
            if (find_it != generated.end()) {
                member.value = find_it->second.value; // Use the generated member
            } else {
                // create new token
                stdu::vector<std::string> new_name = {"AUTO_" + std::to_string(count++)};
                auto mem_copy_for_generated = member;
                auto newRuleMember = member;
                member.value = AST::RuleMemberName {.name = new_name};
                member.isAutoGenerated = true;
                AST::Rule newRule;

                // make the rule to store the data via @ <rule>
                newRuleMember.prefix.clear();
                newRuleMember.quantifier = '\0';
                newRuleMember.prefix.is_key_value = true;

                // add data block
                newRule.data_block = AST::DataBlock {AST::RegularDataBlock {AST::make_expr_from_value(AST::CllExprValue {AST::rvalue {AST::At()}})}};
                // add copied member
                newRule.rule_members = {newRuleMember};

                // Store the generated member
                generated.push_back({mem_copy_for_generated, member});
                toInsert.push_back(std::make_pair(new_name, newRule));
            }
        } else if (member.isGroup()) {
            auto &group = member.getGroup();
            literalsToToken(group.values, count, toInsert, generated);
        } else if (member.isOp()) {
            auto &op = member.getOp();
            literalsToToken(op.options, count, toInsert, generated);
        }
    }
}
void AST::TreePass::literalsToToken(AST::Tree &ast) {
    size_t count = 0;
    stdu::vector<std::pair<AST::RuleMember, AST::RuleMember>> generated;
    stdu::vector<std::pair<stdu::vector<std::string>, AST::Rule>> toInsert;
    auto &treeMap = ast.getTreeMap();
    AST::TreePass pass(ast, true);
    for (auto &[name, value] : treeMap) {
        if (corelib::text::isLower(name.back())) {
            pass.literalsToToken(value.rule_members, count, toInsert, generated);
        }
    }
    for (const auto &[name, newRule] : toInsert) {
        treeMap[name] = newRule;
    }
}
bool AST::TreePass::prioritySort(const AST::String &first, const AST::String &second) {
    if (first.value.size() != second.value.size())
        return first.value.size() > second.value.size();
    return first.value > second.value;
}
bool AST::TreePass::prioritySort(const AST::RuleMemberBin &first, const AST::RuleMemberBin &second) {
    return first.bin_chars.size() > second.bin_chars.size();
}

bool AST::TreePass::prioritySort(const AST::RuleMemberHex &first, const AST::RuleMemberHex &second) {
    return first.hex_chars.size() > second.hex_chars.size();
}

bool AST::TreePass::prioritySort(const AST::RuleMemberName &first, const AST::RuleMemberName &second) {
    auto &treeMap = ast->getTreeMap();
    const auto first_data = treeMap.find(first.name);
    const auto second_data = treeMap.find(second.name);
    if (first_data == treeMap.end())
        throw Error("Not found Rule_name in map");
    if (second_data == treeMap.end())
        throw Error("Not found Rule_name in map");
    const auto &first_rules = first_data->second.rule_members;
    const auto &second_rules = second_data->second.rule_members;
    for (size_t i = 0; i < first_rules.size() && i < second_rules.size(); ++i) {
        if (first_rules[i] == second_rules[i]) {
            continue;
        }
        return prioritySort(first_rules[i], second_rules[i]);
    }
    return first_rules.size() > second_rules.size();
}

bool AST::TreePass::prioritySort(const AST::RuleMemberCsequence &first, const AST::RuleMemberCsequence &second) {
    if (!first.negative && second.negative)
        return true;
    if (first.negative && !second.negative)
        return false;
    return first.characters.size() + first.escaped.size() + first.diapasons.size() >
           second.characters.size() + second.escaped.size() + second.diapasons.size();
}

bool AST::TreePass::prioritySort(const AST::RuleMemberGroup &first, const AST::RuleMemberGroup &second) {
    for (size_t i = 0; i < first.values.size() && i < second.values.size(); ++i) {
        if (first.values[i] == second.values[i])
            continue;
        return prioritySort(first.values[i], second.values[i]);
    }
    return first.values.size() > second.values.size();
}

bool AST::TreePass::prioritySort(const AST::RuleMemberOp &first, const AST::RuleMemberOp &second) {
    return prioritySort(first.options.back(), second.options.back());
}
bool AST::TreePass::prioritySort(const AST::RuleMember &first, const AST::RuleMember &second) {
    if (first.isName() && second.isName())
        return prioritySort(first.getName(), second.getName());
    if (first.isGroup() && second.isGroup())
        return prioritySort(first.getGroup(), second.getGroup());
    if (first.isOp() && second.isOp())
        return prioritySort(first.getOp(), second.getOp());
    if (first.isString() && second.isString())
        return prioritySort(first.getString(), second.getString());
    if (first.isEscaped() && second.isEscaped())
        return false;
    if (first.isCsequence() && second.isCsequence())
        return prioritySort(first.getCsequence(), second.getCsequence());
    if (first.isBin() && second.isBin())
        return prioritySort(first.getBin(), second.getBin());
    if (first.isHex() && second.isHex())
        return prioritySort(first.getHex(), second.getHex());
    if (first.isAny() && second.isAny())
        return false;

    if (first.isName()) {
        auto find_it = ast->getTreeMap().find(first.getName().name);
        if (find_it == ast->getTreeMap().end()) {
            throw Error("Not found Rule_name in map");
        }
        const auto &members = find_it->second.rule_members;
        return stdu::visit([&](const auto &f, const auto &s) -> bool {
            if (members.size() > 1 && getTypes(f) == getTypes(s))
                return false;
            return prioritySort(members[0], second);
        }, members[0].value, second.value);
    }
    if (second.isName()){
        auto find_it = ast->getTreeMap().find(second.getName().name);
        if (find_it == ast->getTreeMap().end()) {
            throw Error("Not found Rule_name in map");
        }
        const auto &members = find_it->second.rule_members;
        return stdu::visit([&](const auto &f, const auto &s) -> bool {
            if (members.size() > 1 && getTypes(f) == getTypes(s))
                return true;
            return prioritySort(first, members[0]);
        }, first.value, members[0].value);
    }
    if (first.isGroup()) {
        auto &dt = first.getGroup();
        if (dt.values.empty())
            throw Error("Empty group");
        return prioritySort(dt.values[0], second);
    }
    if (second.isGroup()) {
        auto &dt = second.getGroup();
        if (dt.values.empty())
            throw Error("Empty group");
        return prioritySort(first, dt.values[0]);
    }
    if (first.isOp()) {
        auto &dt = first.getOp();
        if (dt.options.empty())
            throw Error("Empty op");
        return prioritySort(dt.options.back(), second);
    }
    if (second.isOp()) {
        auto &dt = second.getOp();
        if (dt.options.empty())
            throw Error("Empty op");
        return prioritySort(first, dt.options[0]);
    }
    return stdu::visit([&](const auto &f, const auto &s) -> bool {
        stdu::vector<Types> priority_order = {
            Types::string,
            Types::Rule_escaped,
            Types::Rule_csequence,
            Types::Rule_bin,
            Types::Rule_hex,
            Types::Rule_any,
            Types::cll
        };

        auto first_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(f));
        auto second_pos = std::find(priority_order.begin(), priority_order.end(), getTypes(s));
        if (first_pos != priority_order.end() && second_pos != priority_order.end()) {
            return first_pos < second_pos;
        } else if (first_pos != priority_order.end()) {
            return true;  // known comes before unknown
        } else if (second_pos != priority_order.end()) {
            return false; // unknown comes after known
        }
        return false; // both unknown
    }, first.value, second.value);
}
void AST::TreePass::sortByPriority(AST::Tree &ast, AST::RuleMemberOp& options) {
    AST::TreePass pass(ast, true);
    std::sort(options.options.begin(), options.options.end(), [&](AST::RuleMember &first, AST::RuleMember &second) {
        return pass.prioritySort(first, second);
    });
}
void AST::TreePass::sortByPriority(AST::Tree &ast, stdu::vector<AST::RuleMember>& members) {
    for (auto &member : members) {
        if (member.isGroup()) {
            sortByPriority(ast, member.getGroup().values);
        }
        if (member.isOp()) {
            for (auto &option : member.getOp().options) {
                if (option.isGroup()) {
                    sortByPriority(ast, option.getGroup().values);
                }
            }
            sortByPriority(ast, member.getOp());
        }
    }
}
void AST::TreePass::sortByPriority(AST::Tree &ast) {
    for (auto &[name, value] : ast.getTreeMap()) {
        if (value.rule_members.empty()) {
            throw Error("Empty rule");
        }
        AST::TreePass pass(ast, true);
        pass.sortByPriority(ast, value.rule_members);
    }
}
void AST::TreePass::addSpaceToken(AST::Tree &ast) {
    AST::Rule spaceTokenRule;
    AST::RuleMemberCsequence csequence;
    csequence.escaped = {'t', 'n', 'r', 'v', 'f'};
    csequence.characters = {' '};
    spaceTokenRule.rule_members = { AST::RuleMember { .quantifier = '+', .value = csequence } };
    ast.getTreeMap()[{"__WHITESPACE"}] = spaceTokenRule;
}
void AST::TreePass::removeEmptyRule() {
    removeEmptyRule(*ast);
}
void AST::TreePass::inlineSingleGroups() {
    inlineSingleGroups(*ast);
}
void AST::TreePass::literalsToToken() {
    literalsToToken(*ast);
}
void AST::TreePass::sortByPriority() {
    sortByPriority(*ast);
}
void AST::TreePass::addSpaceToken() {
    addSpaceToken(*ast);
}