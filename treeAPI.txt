name<{ rule, BIN, }> : Rule {
   String (0b)
  @  Cseq([01])+;
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, HEX, }> : Rule {
   String (0x)
  @  Cseq([], Diapasons:[0-9 A-F a-f ])+;
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, NOSPACE, }> : Rule {
   String (\\s0)
  Data: EmptyDataBlock
}name<{ rule, CSEQUENCE, ESCAPE, }> : Rule {
   String (\\)
   NoSpace
  @  Any
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, CSEQUENCE, SYMBOL, }> : Rule {
  @  Group( Op( String (\\) |  !Cseq([]])))
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, OP, }> : Rule {
   String (|)
  Data: EmptyDataBlock
}name<{ rule, data_block, templated_datablock, }> : Rule {
   Name(AT)
   String ({)
   Group(@  Name(ID),  Group( String (,), @  Name(ID))*;)?;
   String (})
  Data: TemplatedDataBlock(first_name, second_name)
}name<{ rule, data_block, regular_datablock, key, }> : Rule {
  @  Name(ID)
   String (=)
  @  Name(cll::expr)
  Data: TemplatedDataBlock(name, dt)
}name<{ rule, data_block, regular_datablock, }> : Rule {
   String ({)
  @  Op( Name(cll::expr) |  Name(rule::data_block::regular_datablock::key)+;)
   String (})
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, loop_while, }> : Rule {
   String (while)
  @  Name(cll::expr)
  @  Name(cll::stmt)
  Data: TemplatedDataBlock(expr, stmt)
}name<{ cll, method_call, }> : Rule {
  @  Name(ID)
   Name(DOT)
  @  Name(cll::function_call)
  Data: TemplatedDataBlock(name, body)
}name<{ cll, COMPARE_OP, }> : Rule {
  @  Op( String (==) |  String (!=) |  String (>) |  String (<) |  String (>=) |  String (<=))
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, expr, group, }> : Rule {
   String (()
  @  Name(cll::expr)
   String ())
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, expr, logical, }> : Rule {
  @  Name(cll::expr::compare)
   Group(@  Name(cll::LOGICAL_OP), @  Name(cll::expr::compare))*;
  Data: TemplatedDataBlock(left, op, right)
}name<{ cll, _var, }> : Rule {
  @  Name(cll::TYPE)?;
  @  Name(ID)
  @  Group( Name(cll::ASSIGNMENT_OP), @  Name(cll::expr))?;
  Data: TemplatedDataBlock(type, id, op, value)
}name<{ cll, function_call, }> : Rule {
  @  Name(ID)
  @  Name(cll::function_body_call)
  Data: TemplatedDataBlock(name, body)
}name<{ cll, }> : Rule {
   String ($)
  @  Op( Name(cll::_var) |  Name(cll::_if) |  Name(cll::expr) |  Name(cll::loop_while) |  Name(cll::loop_for))
   String (;)
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, expr, compare, }> : Rule {
  @  Name(cll::expr::arithmetic)
   Group(@  Name(cll::COMPARE_OP), @  Name(cll::expr::arithmetic))*;
  Data: TemplatedDataBlock(first, operators, sequence)
}name<{ cll, expr, arithmetic, }> : Rule {
  @  Name(cll::expr::term)
   Group(@  Op( Name(PLUS) |  Name(MINUS)), @  Name(cll::expr::term))*;
  Data: TemplatedDataBlock(first, operators, sequence)
}name<{ cll, _if, }> : Rule {
   String (if)
  @  Name(cll::expr)
  @  Name(cll::stmt)
  Data: TemplatedDataBlock(expr, stmt)
}name<{ rule, ESCAPED, }> : Rule {
   String (\\)
   NoSpace
  @  Group( Op( Any))
   NoSpace
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, OP, }> : Rule {
  @  Op( String (+) |  String (-) |  String (*) |  String (/) |  String (%))
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, ASSIGNMENT_OP, }> : Rule {
   Name(cll::OP)?;
  @  String (=)
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, function_parameters, }> : Rule {
   Group(@  Name(ID),  Group( String (,), @  Name(ID))*;)
  Data: TemplatedDataBlock(first, second)
}name<{ cll, function_arguments, }> : Rule {
   Group(@  Name(cll::expr),  Group( String (,), @  Name(cll::expr))*;)
  Data: TemplatedDataBlock(first, second)
}name<{ cll, TEMPLATE, }> : Rule {
   String (<)
  @  Name(cll::TYPE)
   Group( String (,), @  Name(cll::TYPE))*;
   String (>)
  Data: TemplatedDataBlock(first, second)
}name<{ cll, LOGICAL_NOT, }> : Rule {
   Op( String (!) |  String (not))
  Data: EmptyDataBlock
}name<{ cll, LOGICAL_OP, }> : Rule {
  @  Op( Name(cll::LOGICAL_AND) |  Name(cll::LOGICAL_OR))
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, function_decl, }> : Rule {
   String (fn)
  @  Name(ID)+;
  @  Name(cll::function_body_decl)
  @  Name(cll::stmt)?;
  Data: TemplatedDataBlock(type, name, stmt)
}name<{ cll, TYPE, }> : Rule {
   Group(@  Op( String (var) |  String (num) |  String (bool) |  String (str) |  Group(@  String (arr), @  Name(cll::TEMPLATE)) |  Group(@  String (obj), @  Name(cll::TEMPLATE))))
  Data: TemplatedDataBlock(type, templ)
}name<{ cll, _variable, }> : Rule {
  @  Group( Op( String (++) |  String (--)))?;
  @  Name(ID)
   Group( String ([), @  Name(cll::expr),  String (]))?;
  @  Group( Op( String (++) |  String (--)))?;
  Data: TemplatedDataBlock(pre, name, brace_expression, pos)
}name<{ cll, expr, }> : Rule {
  @  Name(cll::expr::logical)
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, function_body_call, }> : Rule {
   String (()
  @  Name(cll::function_arguments)
   String ())
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, stmt, }> : Rule {
   String ({)
  @  Name(rule::member)*;
   String (})
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, }> : Rule {
  @  Name(ID)
   String (:)
  @  Name(rule::member)+;
  @  Name(rule::data_block)?;
  @  Name(rule::nested_rule)*;
   String (;)
  Data: TemplatedDataBlock(name, rule, data_block, nested_rules)
}name<{ cll, LOGICAL_OR, }> : Rule {
   Op( String (||) |  String (or))
  Data: EmptyDataBlock
}name<{ STRING, }> : Rule {
   Group( String (\'), @  Group( Op( Group( String (\\),  NoSpace,  Any) |  !Cseq(['])))*;,  String (\'))
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, value, }> : Rule {
   String (&)
  @  Name(ID)
  Data: [RegularDataBlock: CllExpr]
}name<{ NUMBER, }> : Rule {
  @  Cseq([+-])?;
  @  Group( Cseq([], Diapasons:[0-9 ])+;)
  @  Group( Cseq([.,]),  Cseq([], Diapasons:[0-9 ])+;)?;
  Data: TemplatedDataBlock(sign, main, dec)
}name<{ rule, data_block, }> : Rule {
  @  Op( Name(rule::data_block::templated_datablock) |  Name(rule::data_block::regular_datablock))
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, function_body_decl, }> : Rule {
   String (()
  @  Name(cll::function_parameters)
   String ())
  Data: [RegularDataBlock: CllExpr]
}name<{ BOOLEAN, }> : Rule {
  d Group( Op( String (true) |  String (false)))
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, name, }> : Rule {
  @  String (#)?;
  @  Name(ID)
   Group( String (.), @  Name(ID))*;
  Data: TemplatedDataBlock(is_nested, name, nested_name)
}name<{ array, }> : Rule {
   String ([)
   Group( Group(@  Name(cll::expr),  String (,))*;)?;
   String (])
  Data: [RegularDataBlock: CllExpr]
}name<{ SPACEMODE, }> : Rule {
   String (spacemode)
  @  Op( String (mixed) |  String (skipped) |  String (allowed))
   String (;)
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, member, }> : Rule {
  @  Group( Op( Name(rule::keyvalue) |  Name(rule::value)))?;
  @  Op( Name(rule::name) |  Name(rule::group) |  Name(rule::CSEQUENCE) |  Name(STRING) |  Name(rule::HEX) |  Name(rule::BIN) |  Name(rule::NOSPACE) |  Name(rule::ESCAPED) |  Name(DOT) |  Name(rule::OP) |  Name(LINEAR_COMMENT) |  Name(cll))
  @  Name(rule::quantifier)?;
  Data: TemplatedDataBlock(prefix, val, quantifier)
}name<{ rule, CSEQUENCE, DIAPASON, }> : Rule {
   Group(@  Name(rule::CSEQUENCE::SYMBOL),  NoSpace,  String (-),  NoSpace, @  Name(rule::CSEQUENCE::SYMBOL))
  Data: TemplatedDataBlock(from, to)
}name<{ cll, expr, value, }> : Rule {
  @  Op( Name(cll::expr::group) |  Name(cll::_variable) |  Name(cll::function_call) |  Name(cll::method_call) |  Name(rvalue))
  Data: [RegularDataBlock: CllExpr]
}name<{ cll, LOGICAL_AND, }> : Rule {
   Op( String (&&) |  String (and))
  Data: EmptyDataBlock
}name<{ object, }> : Rule {
   String ({)
   Group(@  Op( Name(ID) |  Name(NUMBER)),  String (:), @  Name(cll::expr),  Group( String (,), @  Op( Name(ID) |  Name(NUMBER)),  String (:), @  Name(cll::expr))*;,  String (;))?;
   String (})
  Data: TemplatedDataBlock(key, value, keys, values)
}name<{ rvalue, }> : Rule {
  @  Op( Name(BOOLEAN) |  Name(NUMBER) |  Name(STRING) |  Name(ID) |  Name(AT) |  Name(array) |  Name(object))
  Data: [RegularDataBlock: CllExpr]
}name<{ QUESTION_MARK, }> : Rule {
   String (?)
  Data: EmptyDataBlock
}name<{ PLUS, }> : Rule {
   String (+)
  Data: EmptyDataBlock
}name<{ MINUS, }> : Rule {
   String (-)
  Data: EmptyDataBlock
}name<{ DIVIDE, }> : Rule {
   String (/)
  Data: EmptyDataBlock
}name<{ cll, expr, term, }> : Rule {
  @  Name(cll::expr::value)
   Group(@  Op( Name(MULTIPLE) |  Name(DIVIDE) |  Name(MODULO)), @  Name(cll::expr::value))*;
  Data: TemplatedDataBlock(first, operators, sequence)
}name<{ MULTIPLE, }> : Rule {
   String (*)
  Data: EmptyDataBlock
}name<{ rule, keyvalue, }> : Rule {
   Name(AT)
   Group( NoSpace, @  Name(ID))?;
  Data: [RegularDataBlock: CllExpr]
}name<{ MODULO, }> : Rule {
   String (%)
  Data: EmptyDataBlock
}name<{ AT, }> : Rule {
   String (@)
  Data: EmptyDataBlock
}name<{ DOT, }> : Rule {
   String (.)
  Data: EmptyDataBlock
}name<{ ID, }> : Rule {
  @  Group( Cseq([_], Diapasons:[a-z A-Z ]),  Cseq([_], Diapasons:[a-z A-Z 0-9 ])*;)
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, CSEQUENCE, }> : Rule {
   String ([)
  @  String (^)?;
  @  Group( Op( Name(rule::CSEQUENCE::ESCAPE) |  Name(rule::CSEQUENCE::SYMBOL) |  Name(rule::CSEQUENCE::DIAPASON)))*;
   String (])
  Data: TemplatedDataBlock(_not, val)
}name<{ rule, quantifier, }> : Rule {
  @  Op( Name(QUESTION_MARK) |  Name(PLUS) |  Name(MULTIPLE))
  Data: [RegularDataBlock: CllExpr]
}name<{ LINEAR_COMMENT, }> : Rule {
   String (//)
   !Cseq([n])*;
  Data: EmptyDataBlock
}name<{ main, }> : Rule {
   Group(@  Op( Name(_use) |  Name(rule) |  Name(NAME) |  Name(SPACEMODE)))+;
  Data: [RegularDataBlock: CllExpr]
}name<{ _use, }> : Rule {
   String (use)
  @  Name(_use::unit)
   Group( String (,), @  Name(_use::unit))*;
   String (;)
  Data: TemplatedDataBlock(first, second)
}name<{ cll, loop_for, }> : Rule {
   String (for)
   String (()
  @  Group( Op( Name(cll::expr) |  Name(cll::_var)))?;
   String (;)
  @  Name(cll::expr)?;
   String (;)
  @  Name(cll::expr)?;
   String ())
  @  Name(cll::stmt)
  Data: TemplatedDataBlock(decl, cond, end, stmt)
}name<{ rule, nested_rule, }> : Rule {
   String (#)
   NoSpace
  @  Name(rule)
  Data: [RegularDataBlock: CllExpr]
}name<{ _use, unit, }> : Rule {
  @  Name(ID)
  @  Name(rvalue)?;
  Data: TemplatedDataBlock(name, value)
}name<{ NAME, }> : Rule {
   String (name)
  @  Name(ID)
   String (;)
  Data: [RegularDataBlock: CllExpr]
}name<{ rule, group, }> : Rule {
   String (()
  @  Name(rule::member)*;
   String ())
  Data: [RegularDataBlock: CllExpr]
}