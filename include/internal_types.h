#pragma once
#include <any>
#include <string>
#include <vector>
#include <unordered_map>
#include <set>
#include <IR/IR.h>
#include <utility>
using obj_t = std::unordered_map<const char*, std::any>;
using use_prop_t = std::unordered_map<std::string, Parser::Rule>;
struct rule_other {
    std::string name;
    std::vector<std::string> fullname;
    bool is_autogenerated = false;
    bool operator==(const rule_other& other) const {
        return fullname == other.fullname;
    }
    friend bool operator<(const rule_other &lhs, const rule_other &rhs) {
        return lhs.fullname < rhs.fullname;
    }
};
// Custom hash combine helper (used to combine multiple hashes)
inline void hash_combine(std::size_t& seed, const std::size_t& value) {
    seed ^= value + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// Specialize std::hash for rule_other
namespace std {
    template <>
    struct hash<rule_other> {
        std::size_t operator()(const rule_other& r) const {
            std::size_t seed = 0;

            for (const auto& s : r.fullname) {
                hash_combine(seed, std::hash<std::string>{}(s));
            }

            // Optional: include is_autogenerated in the hash
            hash_combine(seed, std::hash<bool>{}(r.is_autogenerated));

            return seed;
        }
    };
    template <>
    struct hash<std::tuple<rule_other, std::vector<rule_other>, size_t>> {
        std::size_t operator()(const std::tuple<rule_other, std::vector<rule_other>, size_t>& t) const {
            const auto& [r1, rvec, rsize] = t;
            std::size_t h = 0;

            // Hash rule_other (assuming std::hash<rule_other> is defined)
            h ^= std::hash<rule_other>{}(r1) + 0x9e3779b9 + (h << 6) + (h >> 2);

            // Hash std::vector<rule_other>
            for (const auto& r : rvec) {
                h ^= std::hash<rule_other>{}(r) + 0x9e3779b9 + (h << 6) + (h >> 2);
            }

            // Hash size_t
            h ^= std::hash<size_t>{}(rsize) + 0x9e3779b9 + (h << 6) + (h >> 2);

            return h;
        }
    };
    template <>
    struct hash<std::set<std::tuple<rule_other, std::vector<rule_other>, size_t>>> {
        size_t operator()(const std::set<std::tuple<rule_other, std::vector<rule_other>, size_t>>& s) const {
            size_t hash_val = 0;
            for (const auto& element : s) {
                // Hash each element in the set (which is a tuple)
                hash_val ^= std::hash<std::tuple<rule_other, std::vector<rule_other>, size_t>>{}(element) + 0x9e3779b9 + (hash_val << 6) + (hash_val >> 2);
            }
            return hash_val;
        }
    };
}
struct data_block_part {
    std::string name;
    LLIR::data_block value;
};
using data_block_t = std::vector<data_block_part>;
struct lexer_code {
    LLIR code;
    LLIR::node_ret_t success_var;
    lexer_code(LLIR code, LLIR::node_ret_t success_var) : code(code), success_var(success_var) {}
};
struct VectorHash {
    template <typename T>
    size_t operator () (const std::vector<T>& vec) const {
        size_t seed = 0;
        for (const auto& elem : vec) {
            seed ^= std::hash<T>{}(elem) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        }
        return seed;
    }
};