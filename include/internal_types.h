#pragma once
#include <any>
#include <string>
#include <vector>
#include <unordered_map>
#include <set>
#include <IR/IR.h>
#include <utility>
using obj_t = std::unordered_map<const char*, std::any>;
using use_prop_t = std::unordered_map<std::string, Parser::Rule>;
struct rule_other {
    std::string name;
    std::vector<std::string> fullname;
    bool is_autogenerated = false;
    bool operator==(const rule_other& other) const {
        return fullname == other.fullname;
    }
    friend bool operator<(const rule_other &lhs, const rule_other &rhs) {
        return lhs.fullname < rhs.fullname;
    }
};
using use_place_t_part = std::pair<std::vector<std::string>, std::vector<std::vector<std::string>>>;
using use_place_t = std::vector<use_place_t_part>;
struct data_block_part {
    std::string name;
    LLIR::data_block value;
};
using data_block_t = std::vector<data_block_part>;
struct lexer_code {
    LLIR code;
    LLIR::node_ret_t success_var;
    lexer_code(LLIR code, LLIR::node_ret_t success_var) : code(code), success_var(success_var) {}
};