#pragma once
#include <any>
#include <string>
#include <vector>
#include <unordered_map>
#include <set>
#include <IR/IR.h>
#include <utility>
using obj_t = std::unordered_map<const char*, std::any>;
using use_prop_t = std::unordered_map<std::string, Parser::Rule>;
struct rule_other {
    std::string name;
    std::vector<std::string> fullname;
    bool is_autogenerated = false;
    bool operator==(const rule_other& other) const {
        return fullname == other.fullname;
    }
    friend bool operator<(const rule_other &lhs, const rule_other &rhs) {
        return lhs.fullname < rhs.fullname;
    }
};
// Custom hash combine helper (used to combine multiple hashes)
inline void hash_combine(std::size_t& seed, const std::size_t& value) {
    seed ^= value + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// Specialize std::hash for rule_other
namespace std {
    template <>
    struct hash<rule_other> {
        std::size_t operator()(const rule_other& r) const {
            std::size_t seed = 0;

            for (const auto& s : r.fullname) {
                hash_combine(seed, std::hash<std::string>{}(s));
            }

            // Optional: include is_autogenerated in the hash
            hash_combine(seed, std::hash<bool>{}(r.is_autogenerated));

            return seed;
        }
    };

}
struct data_block_part {
    std::string name;
    LLIR::data_block value;
};
using data_block_t = std::vector<data_block_part>;
struct lexer_code {
    LLIR code;
    LLIR::node_ret_t success_var;
    lexer_code(LLIR code, LLIR::node_ret_t success_var) : code(code), success_var(success_var) {}
};
namespace std {
    template <typename T>
    struct hash<vector<T>> {
        size_t operator()(const vector<T>& vec) const noexcept {
            size_t seed = vec.size();  // Start with size as base
            for (const auto& elem : vec) {
                // Combine element hash with seed using the same method as boost::hash_combine
                seed ^= hash<T>{}(elem) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            }
            return seed;
        }
    };
}
namespace std {
    template<typename T>
    struct hash<unordered_set<T>> {
        size_t operator()(const unordered_set<T>& set) const noexcept {
            size_t seed = set.size();  // Include size in hash
            for (const auto& elem : set) {
                seed ^= hash<T>{}(elem) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            }
            return seed;
        }
    };
}