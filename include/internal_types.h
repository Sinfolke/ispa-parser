#pragma once
#include <any>
#include <string>
#include <vector>
#include <unordered_map>
#include <set>
#include <IR/IR.h>
#include <utility>
using obj_t = std::unordered_map<const char*, std::any>;
template<typename T>
using arr_t = std::vector<T>;
using use_prop_t = std::unordered_map<std::string, Parser::Rule>;
struct rule_other {
    std::string name;
    arr_t<std::string> fullname;
    bool is_autogenerated = false;
};
using use_place_t_part = std::pair<std::vector<std::string>, std::vector<std::vector<std::string>>>;
using use_place_t = std::vector<use_place_t_part>;
struct data_block_part {
    std::string name;
    IR::data_block value;
};
using data_block_t = std::vector<data_block_part>;
struct lexer_code {
    IR code;
    IR::node_ret_t success_var;
    lexer_code(IR code, IR::node_ret_t success_var) : code(code), success_var(success_var) {}
};
struct Conflict {
    std::vector<Parser::Rule>* lhs_rule;
    std::vector<Parser::Rule>* rhs_rule;
    std::vector<Parser::Rule>::iterator lhs_it;
    std::vector<Parser::Rule>::iterator rhs_it;
};
using ConflictsList = std::vector<Conflict>;